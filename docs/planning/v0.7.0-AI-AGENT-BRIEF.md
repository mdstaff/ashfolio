# AI Agent Brief: v0.7.0 Advanced Portfolio Analytics Implementation

## Your Mission

You are tasked with implementing v0.7.0 - Advanced Portfolio Analytics for Ashfolio, a personal financial management application. This version builds institutional-grade portfolio analysis capabilities on top of the existing foundation.

## Current State

- **Version**: v0.6.0 complete (Corporate Actions Engine)
- **Tests**: 1,776+ passing (with 12 minor failures to fix first)
- **Foundation**: RiskMetricsCalculator already exists with Sharpe/Sortino ratios
- **Stack**: Phoenix LiveView + Ash 3.4 + SQLite + Decimal arithmetic

## Your Starting Point

1. **READ FIRST**:
   - `/docs/planning/IMPLEMENTATION_PLAN.md` - Your complete roadmap
   - `/lib/ashfolio/portfolio/calculators/risk_metrics_calculator.ex` - Existing patterns
   - `/CLAUDE.md` - Critical development rules (especially HEEx templates)

2. **IMMEDIATE ACTIONS**:
   ```bash
   # 1. Generate Code GPS to understand codebase
   mix code_gps

   # 2. Run tests to verify starting state
   just test

   # 3. Create feature branch
   git checkout -b feature/v0.7.0-portfolio-analytics
   ```

3. **FIX EXISTING TEST FAILURES** (if still present):
   - Check `test/ashfolio_web/live/advanced_analytics_live_test.exs:307`
   - Check `test/ashfolio_web/live/corporate_action_live/form_component_test.exs:264`
   - Run `just test` to confirm all tests pass before starting new work

## Implementation Strategy

### Stage 1: Beta & Enhanced Risk Metrics (Start Here)

**CRITICAL TDD WORKFLOW**:
```elixir
# 1. ALWAYS write the test first
# Create: test/ashfolio/portfolio/calculators/beta_calculator_test.exs

defmodule Ashfolio.Portfolio.Calculators.BetaCalculatorTest do
  use Ashfolio.DataCase, async: true
  alias Ashfolio.Portfolio.Calculators.BetaCalculator
  alias Decimal, as: D

  describe "calculate/2" do
    test "returns beta of 1.0 for market portfolio" do
      market_returns = [D.new("0.05"), D.new("-0.03"), D.new("0.02")]
      portfolio_returns = market_returns  # Identical to market

      assert {:ok, result} = BetaCalculator.calculate(portfolio_returns, market_returns)
      assert_in_delta(D.to_float(result.beta), 1.0, 0.01)
    end

    test "handles insufficient data gracefully" do
      assert {:error, :insufficient_data} = BetaCalculator.calculate([D.new("0.05")], [D.new("0.03")])
    end
  end
end

# 2. Run the test - it MUST fail
mix test test/ashfolio/portfolio/calculators/beta_calculator_test.exs

# 3. Create minimal implementation to pass
# Create: lib/ashfolio/portfolio/calculators/beta_calculator.ex

defmodule Ashfolio.Portfolio.Calculators.BetaCalculator do
  @moduledoc """
  Calculates portfolio beta relative to market benchmark.

  Beta = Covariance(Portfolio, Market) / Variance(Market)

  Reference: CAPM model (Sharpe, 1964)
  """

  alias Decimal, as: D

  def calculate(portfolio_returns, market_returns)
      when length(portfolio_returns) < 2 or length(market_returns) < 2 do
    {:error, :insufficient_data}
  end

  def calculate(portfolio_returns, market_returns) do
    # Implementation here
    covariance = calculate_covariance(portfolio_returns, market_returns)
    variance = calculate_variance(market_returns)

    beta = D.div(covariance, variance)
    {:ok, %{beta: beta, covariance: covariance, market_variance: variance}}
  end
end

# 4. Run test again - make it pass
# 5. Refactor if needed
# 6. Commit with clear message
```

### Critical Success Factors

1. **ALWAYS USE DECIMAL**: Never use Float for any financial calculation
   ```elixir
   # ❌ WRONG
   beta = covariance / variance

   # ✅ CORRECT
   beta = D.div(covariance, variance)
   ```

2. **FOLLOW EXISTING PATTERNS**: Study RiskMetricsCalculator for structure
   ```elixir
   # Look at existing pattern in risk_metrics_calculator.ex
   # Copy the module structure, documentation style, error handling
   ```

3. **TEST EDGE CASES**: Every calculator needs these tests
   - Empty data → `{:error, :insufficient_data}`
   - Single value → `{:error, :insufficient_data}`
   - Zero variance → `{:error, :zero_variance}`
   - Nil values → `{:error, :invalid_data}`

4. **PERFORMANCE BENCHMARKS**: Add performance tests
   ```elixir
   test "calculates beta for 1000 returns in under 100ms" do
     returns = generate_returns(1000)

     {time, {:ok, _}} = :timer.tc(fn ->
       BetaCalculator.calculate(returns, returns)
     end)

     assert time < 100_000  # microseconds
   end
   ```

## Week 1 Deliverables

By end of Week 1, you should have:

1. ✅ Feature branch created
2. ✅ BetaCalculator with 10+ tests, all passing
3. ✅ DrawdownCalculator with recovery time tracking
4. ✅ Enhanced RiskMetricsCalculator with Calmar/Sterling ratios
5. ✅ MarketDataFixtures module with test data

## Common Mistakes to Avoid

1. **DON'T** implement without writing tests first
2. **DON'T** use Float - always Decimal
3. **DON'T** forget to run `mix format` before committing
4. **DON'T** skip edge case handling
5. **DON'T** create new patterns - follow existing ones

## Validation Commands

Run these frequently:
```bash
# Every 30 minutes
mix compile --warnings-as-errors
mix format
just test

# Before commits
mix credo
just check

# After implementing each calculator
mix code_gps  # Verify integration detected
```

## When Stuck

After 3 failed attempts on any component:
1. Document what you tried and specific errors
2. Look for similar implementations in codebase
3. Check if a simpler approach exists
4. Ask: "Can I break this into smaller pieces?"

## Resources

- Implementation Plan: `/docs/planning/IMPLEMENTATION_PLAN.md`
- Existing Calculator: `/lib/ashfolio/portfolio/calculators/risk_metrics_calculator.ex`
- Test Patterns: `/test/ashfolio/portfolio/calculators/risk_metrics_calculator_test.exs`
- Development Rules: `/CLAUDE.md`

## Success Metrics

Your implementation is successful when:
- [ ] 200+ new tests, all passing
- [ ] All calculations < 100ms for 1000 positions
- [ ] Code GPS detects all new calculators
- [ ] No compilation warnings
- [ ] Mix format applied
- [ ] Credo warnings addressed
- [ ] LiveView integration working

## Final Note

Remember: This is a financial application where accuracy is critical. When in doubt:
- Add more tests
- Use Decimal for precision
- Handle edge cases explicitly
- Document formulas clearly
- Validate against known values

Start with Stage 1 (Beta Calculator) using strict TDD. Write the test, watch it fail, then implement just enough to pass. This methodical approach ensures quality and completeness.

Good luck! The plan in IMPLEMENTATION_PLAN.md has everything you need.