# v0.7.0 Stage 3: Portfolio Optimization - Refined TDD Plan

## Executive Summary

**Architect-Approved Scope Refinement**: Focus on 2-3 asset analytical optimization with clear mathematical validation, deferring multi-asset complexity to v0.8.0.

**Timeline**: 4 weeks (October-November 2025)
**Test Target**: 80+ new tests with 100% passing
**Performance**: <10ms for two-asset optimization, <50ms for frontier generation

## Week 1: Two-Asset Analytical Foundation

### Day 1: Core Two-Asset Optimization

#### Task 3.1.1: Minimum Variance Portfolio (Morning)
```elixir
# TEST 1: Basic minimum variance calculation
test "finds minimum variance portfolio for two assets" do
  asset_a = %{symbol: "STOCK", volatility: D.new("0.20")}
  asset_b = %{symbol: "BOND", volatility: D.new("0.05")}
  correlation = D.new("0.2")

  {:ok, result} = TwoAssetOptimizer.minimum_variance(asset_a, asset_b, correlation)

  # Formula: w1 = (σ₂² - σ₁σ₂ρ) / (σ₁² + σ₂² - 2σ₁σ₂ρ)
  # Expected: ~11% Stock, 89% Bond
  assert_in_delta(D.to_float(result.weight_a), 0.106, 0.001)
  assert_in_delta(D.to_float(result.weight_b), 0.894, 0.001)
end

# TEST 2: Portfolio volatility calculation
test "calculates portfolio volatility correctly" do
  # σp² = w₁²σ₁² + w₂²σ₂² + 2w₁w₂σ₁σ₂ρ
  expected_variance = 0.0226²(0.20²) + 0.894²(0.05²) + 2(0.106)(0.894)(0.20)(0.05)(0.2)
  assert_in_delta(D.to_float(result.portfolio_volatility), 0.0485, 0.0001)
end
```

#### Task 3.1.2: Perfect Correlation Edge Cases (Afternoon)
```elixir
# TEST 3: Perfect positive correlation (ρ = 1)
test "handles perfectly correlated assets" do
  {:ok, result} = TwoAssetOptimizer.minimum_variance(asset_a, asset_b, D.new("1.0"))

  # With ρ = 1, choose 100% lower volatility asset
  assert D.equal?(result.weight_b, D.new("1.0"))
  assert D.equal?(result.weight_a, D.new("0.0"))
end

# TEST 4: Perfect negative correlation (ρ = -1)
test "achieves zero variance with perfect negative correlation" do
  {:ok, result} = TwoAssetOptimizer.minimum_variance(asset_a, asset_b, D.new("-1.0"))

  # Can achieve σp = 0 with w₁ = σ₂/(σ₁ + σ₂)
  assert_in_delta(D.to_float(result.weight_a), 0.20, 0.001)
  assert_in_delta(D.to_float(result.portfolio_volatility), 0.0, 0.0001)
end

# TEST 5: Zero correlation independence
test "handles independent assets (ρ = 0)" do
  {:ok, result} = TwoAssetOptimizer.minimum_variance(asset_a, asset_b, D.new("0"))

  # Simplified formula when ρ = 0
  assert_in_delta(D.to_float(result.weight_a), 0.059, 0.001)
end
```

### Day 2: Target Return Optimization

#### Task 3.1.3: Return-Targeted Portfolios
```elixir
# TEST 6: Optimize for specific return target
test "finds minimum risk portfolio for 10% return target" do
  asset_a = %{expected_return: D.new("0.12"), volatility: D.new("0.20")}
  asset_b = %{expected_return: D.new("0.08"), volatility: D.new("0.15")}
  correlation = D.new("0.3")
  target = D.new("0.10")

  {:ok, result} = TwoAssetOptimizer.optimize_for_return(
    asset_a, asset_b, correlation, target
  )

  # Verify return constraint met
  portfolio_return = D.add(
    D.mult(result.weight_a, asset_a.expected_return),
    D.mult(result.weight_b, asset_b.expected_return)
  )
  assert_in_delta(D.to_float(portfolio_return), 0.10, 0.0001)

  # Should be 50% Stock, 50% Bond for 10% target
  assert_in_delta(D.to_float(result.weight_a), 0.50, 0.001)
end

# TEST 7: Infeasible return targets
test "rejects return target above maximum asset return" do
  assert {:error, :infeasible_target} =
    TwoAssetOptimizer.optimize_for_return(asset_a, asset_b, corr, D.new("0.15"))
end

# TEST 8: Infeasible return targets below minimum
test "rejects return target below minimum asset return" do
  assert {:error, :infeasible_target} =
    TwoAssetOptimizer.optimize_for_return(asset_a, asset_b, corr, D.new("0.05"))
end
```

#### Task 3.1.4: Input Validation
```elixir
# TEST 9-15: Validation suite
test "rejects correlation > 1" do
  assert {:error, :invalid_correlation} =
    TwoAssetOptimizer.minimum_variance(asset_a, asset_b, D.new("1.1"))
end

test "rejects correlation < -1" do
  assert {:error, :invalid_correlation} =
    TwoAssetOptimizer.minimum_variance(asset_a, asset_b, D.new("-1.1"))
end

test "rejects negative volatility" do
  invalid = %{volatility: D.new("-0.10")}
  assert {:error, :invalid_volatility} =
    TwoAssetOptimizer.minimum_variance(invalid, asset_b, D.new("0.3"))
end

test "rejects zero volatility for both assets" do
  zero_a = %{volatility: D.new("0")}
  zero_b = %{volatility: D.new("0")}
  assert {:error, :degenerate_case} =
    TwoAssetOptimizer.minimum_variance(zero_a, zero_b, D.new("0.3"))
end

test "handles one zero-volatility asset" do
  zero_vol = %{volatility: D.new("0")}
  {:ok, result} = TwoAssetOptimizer.minimum_variance(zero_vol, asset_b, D.new("0.3"))
  assert D.equal?(result.weight_zero, D.new("1.0"))
end

test "validates weight sum equals 1" do
  {:ok, result} = TwoAssetOptimizer.minimum_variance(asset_a, asset_b, correlation)
  sum = D.add(result.weight_a, result.weight_b)
  assert D.equal?(sum, D.new("1.0"))
end
```

### Day 3: Sharpe Ratio & Risk Metrics

#### Task 3.1.5: Maximum Sharpe Ratio Portfolio
```elixir
# TEST 16: Find tangency portfolio
test "finds maximum Sharpe ratio portfolio" do
  asset_a = %{expected_return: D.new("0.12"), volatility: D.new("0.20")}
  asset_b = %{expected_return: D.new("0.08"), volatility: D.new("0.15")}
  correlation = D.new("0.3")
  risk_free = D.new("0.03")

  {:ok, tangency} = TwoAssetOptimizer.maximum_sharpe(
    asset_a, asset_b, correlation, risk_free
  )

  # Should find portfolio with highest (return - rf) / volatility
  sharpe_a = D.div(D.sub(asset_a.expected_return, risk_free), asset_a.volatility)
  sharpe_b = D.div(D.sub(asset_b.expected_return, risk_free), asset_b.volatility)

  assert D.compare(tangency.sharpe_ratio, sharpe_a) == :gt
  assert D.compare(tangency.sharpe_ratio, sharpe_b) == :gt
end

# TEST 17: Sharpe ratio calculation
test "calculates Sharpe ratio correctly" do
  weights = %{weight_a: D.new("0.6"), weight_b: D.new("0.4")}
  risk_free = D.new("0.03")

  {:ok, metrics} = TwoAssetOptimizer.calculate_metrics(
    asset_a, asset_b, correlation, weights, risk_free
  )

  # Manual calculation
  expected_return = 0.6 * 0.12 + 0.4 * 0.08  # 0.104
  variance = 0.6² * 0.20² + 0.4² * 0.15² + 2 * 0.6 * 0.4 * 0.20 * 0.15 * 0.3
  volatility = sqrt(variance)  # ~0.148
  expected_sharpe = (0.104 - 0.03) / 0.148  # ~0.5

  assert_in_delta(D.to_float(metrics.sharpe_ratio), 0.5, 0.01)
end
```

### Day 4: Numerical Stability & Edge Cases

#### Task 3.1.6: Extreme Value Testing
```elixir
# TEST 18-25: Numerical stability suite
test "handles near-zero volatility difference" do
  asset_a = %{volatility: D.new("0.1000")}
  asset_b = %{volatility: D.new("0.1001")}

  {:ok, result} = TwoAssetOptimizer.minimum_variance(asset_a, asset_b, D.new("0.5"))

  # Should be approximately equal weights
  assert_in_delta(D.to_float(result.weight_a), 0.5, 0.1)
end

test "handles very high correlation (0.9999)" do
  {:ok, result} = TwoAssetOptimizer.minimum_variance(asset_a, asset_b, D.new("0.9999"))

  # Should heavily favor lower volatility
  assert D.compare(result.weight_b, D.new("0.99")) == :gt
end

test "handles very low correlation (-0.9999)" do
  {:ok, result} = TwoAssetOptimizer.minimum_variance(asset_a, asset_b, D.new("-0.9999"))

  # Near-zero portfolio volatility possible
  assert D.compare(result.portfolio_volatility, D.new("0.001")) == :lt
end

test "maintains precision with small differences" do
  asset_a = %{expected_return: D.new("0.1000"), volatility: D.new("0.20")}
  asset_b = %{expected_return: D.new("0.1001"), volatility: D.new("0.20")}

  {:ok, result} = TwoAssetOptimizer.optimize_for_return(
    asset_a, asset_b, D.new("0.5"), D.new("0.10005")
  )

  # Should calculate precise weights for tiny return difference
  assert_in_delta(D.to_float(result.weight_a), 0.50, 0.01)
end
```

### Day 5: Performance Benchmarks

#### Task 3.1.7: Performance Requirements
```elixir
# TEST 26-30: Performance suite
@tag :performance
test "two-asset minimum variance < 5ms" do
  {time, {:ok, _}} = :timer.tc(fn ->
    TwoAssetOptimizer.minimum_variance(asset_a, asset_b, correlation)
  end)

  assert time < 5_000  # microseconds
end

@tag :performance
test "100 optimizations < 100ms" do
  {time, _} = :timer.tc(fn ->
    for _ <- 1..100 do
      TwoAssetOptimizer.minimum_variance(asset_a, asset_b, correlation)
    end
  end)

  assert time < 100_000
end

@tag :performance
test "Sharpe maximization < 10ms" do
  {time, {:ok, _}} = :timer.tc(fn ->
    TwoAssetOptimizer.maximum_sharpe(asset_a, asset_b, correlation, risk_free)
  end)

  assert time < 10_000
end
```

## Week 2: Three-Asset Semi-Analytical & Frontier Generation

### Day 6-7: Three-Asset Extension

#### Task 3.2.1: Three-Asset Data Structures
```elixir
# TEST 31-35: Three-asset covariance matrix
test "builds 3x3 covariance matrix" do
  assets = [
    %{symbol: "A", volatility: D.new("0.20")},
    %{symbol: "B", volatility: D.new("0.15")},
    %{symbol: "C", volatility: D.new("0.10")}
  ]

  correlations = %{
    {"A", "B"} => D.new("0.3"),
    {"A", "C"} => D.new("0.1"),
    {"B", "C"} => D.new("0.4")
  }

  {:ok, cov_matrix} = ThreeAssetOptimizer.build_covariance_matrix(assets, correlations)

  # Verify diagonal = variance
  assert D.equal?(cov_matrix[0][0], D.new("0.04"))    # 0.20²
  assert D.equal?(cov_matrix[1][1], D.new("0.0225"))  # 0.15²
  assert D.equal?(cov_matrix[2][2], D.new("0.01"))    # 0.10²

  # Verify symmetry
  assert D.equal?(cov_matrix[0][1], cov_matrix[1][0])
  assert D.equal?(cov_matrix[0][2], cov_matrix[2][0])
  assert D.equal?(cov_matrix[1][2], cov_matrix[2][1])
end

test "handles singular covariance matrix" do
  # All correlations = 1 creates singular matrix
  correlations = %{
    {"A", "B"} => D.new("1.0"),
    {"A", "C"} => D.new("1.0"),
    {"B", "C"} => D.new("1.0")
  }

  assert {:error, :singular_matrix} =
    ThreeAssetOptimizer.minimum_variance(assets, correlations)
end
```

#### Task 3.2.2: Three-Asset Minimum Variance
```elixir
# TEST 36-40: Three-asset optimization
test "finds minimum variance for three assets" do
  # Known academic example
  {:ok, result} = ThreeAssetOptimizer.minimum_variance(assets, correlations)

  # All weights positive and sum to 1
  assert D.compare(result.weight_a, D.new("0")) != :lt
  assert D.compare(result.weight_b, D.new("0")) != :lt
  assert D.compare(result.weight_c, D.new("0")) != :lt

  sum = Enum.reduce([result.weight_a, result.weight_b, result.weight_c],
    D.new("0"), &D.add/2)
  assert D.equal?(sum, D.new("1.0"))
end

test "three-asset with one dominant low-risk asset" do
  assets = [
    %{volatility: D.new("0.30")},  # High risk
    %{volatility: D.new("0.25")},  # Medium risk
    %{volatility: D.new("0.02")}   # Very low risk
  ]

  {:ok, result} = ThreeAssetOptimizer.minimum_variance(assets, low_correlations)

  # Should heavily favor low-risk asset
  assert D.compare(result.weight_c, D.new("0.80")) == :gt
end
```

### Day 8-9: Efficient Frontier Generation

#### Task 3.3.1: Two-Asset Frontier
```elixir
# TEST 41-50: Frontier generation
test "generates efficient frontier for two assets" do
  {:ok, frontier} = TwoAssetFrontier.generate(
    asset_a, asset_b, correlation,
    points: 20
  )

  assert length(frontier.portfolios) == 20

  # Verify ordering by volatility
  volatilities = Enum.map(frontier.portfolios, & &1.volatility)
  assert volatilities == Enum.sort(volatilities)

  # Verify return generally increases with risk
  returns = Enum.map(frontier.portfolios, & &1.expected_return)

  increasing_pairs = Enum.chunk_every(returns, 2, 1, :discard)
    |> Enum.count(fn [a, b] -> D.compare(b, a) != :lt end)

  assert increasing_pairs >= 15  # Most pairs should be increasing
end

test "frontier includes minimum variance point" do
  {:ok, frontier} = TwoAssetFrontier.generate(asset_a, asset_b, correlation)
  {:ok, min_var} = TwoAssetOptimizer.minimum_variance(asset_a, asset_b, correlation)

  # Find closest frontier point to minimum variance
  closest = Enum.min_by(frontier.portfolios, fn p ->
    abs(D.to_float(D.sub(p.volatility, min_var.portfolio_volatility)))
  end)

  assert_in_delta(D.to_float(closest.volatility),
    D.to_float(min_var.portfolio_volatility), 0.001)
end

test "frontier is concave (diminishing returns)" do
  {:ok, frontier} = TwoAssetFrontier.generate(asset_a, asset_b, correlation)

  points = frontier.portfolios |> Enum.take(10)

  # Check second derivative is negative (concavity)
  for i <- 1..7 do
    p1 = Enum.at(points, i - 1)
    p2 = Enum.at(points, i)
    p3 = Enum.at(points, i + 1)

    # Calculate slopes
    slope1 = D.to_float(D.sub(p2.expected_return, p1.expected_return)) /
             D.to_float(D.sub(p2.volatility, p1.volatility))
    slope2 = D.to_float(D.sub(p3.expected_return, p2.expected_return)) /
             D.to_float(D.sub(p3.volatility, p2.volatility))

    # Slope should decrease (concavity)
    assert slope2 <= slope1 + 0.01  # Small tolerance for numerical error
  end
end
```

### Day 10: Capital Market Line & Special Points

#### Task 3.3.2: CML and Tangency Portfolio
```elixir
# TEST 51-55: Capital Market Line
test "identifies tangency portfolio on frontier" do
  risk_free = D.new("0.03")
  {:ok, frontier} = TwoAssetFrontier.generate(asset_a, asset_b, correlation)
  {:ok, tangency} = TwoAssetFrontier.find_tangency_portfolio(frontier, risk_free)

  # Tangency has maximum Sharpe ratio
  all_sharpe = Enum.map(frontier.portfolios, fn p ->
    D.div(D.sub(p.expected_return, risk_free), p.volatility)
  end)

  max_sharpe = Enum.max(all_sharpe)
  assert_in_delta(D.to_float(tangency.sharpe_ratio), D.to_float(max_sharpe), 0.001)
end

test "capital market line passes through tangency" do
  risk_free = D.new("0.03")
  {:ok, tangency} = TwoAssetOptimizer.maximum_sharpe(asset_a, asset_b, correlation, risk_free)

  # CML slope = (tangency_return - rf) / tangency_volatility
  cml_slope = D.div(
    D.sub(tangency.expected_return, risk_free),
    tangency.portfolio_volatility
  )

  # Point on CML at volatility σ
  test_vol = D.new("0.10")
  cml_return = D.add(risk_free, D.mult(cml_slope, test_vol))

  # For leveraged portfolio (borrowing at rf to invest in tangency)
  leverage = D.div(test_vol, tangency.portfolio_volatility)
  leveraged_return = D.add(
    D.mult(D.sub(D.new("1"), leverage), risk_free),
    D.mult(leverage, tangency.expected_return)
  )

  # Should match CML
  assert_in_delta(D.to_float(cml_return), D.to_float(leveraged_return), 0.001)
end
```

## Week 3: Visualization & LiveView Integration

### Day 11-12: SVG Chart Component

#### Task 3.4.1: Frontier Chart Rendering
```elixir
# TEST 56-65: Chart component
test "renders efficient frontier SVG chart" do
  frontier_data = generate_test_frontier()

  assigns = %{
    frontier: frontier_data,
    current_portfolio: %{volatility: D.new("0.15"), expected_return: D.new("0.09")},
    show_tangency: true,
    show_min_variance: true
  }

  html = rendered_to_string(EfficientFrontierChart.render(assigns))

  # Verify SVG structure
  assert html =~ ~r/<svg[^>]*viewBox="0 0 \d+ \d+"/
  assert html =~ "class=\"frontier-curve\""
  assert html =~ "class=\"current-portfolio-marker\""
  assert html =~ "class=\"tangency-marker\""
  assert html =~ "class=\"min-variance-marker\""

  # Verify axes
  assert html =~ "Volatility (%)"
  assert html =~ "Expected Return (%)"
end

test "scales chart to fit data range" do
  frontier_data = %{
    portfolios: [
      %{volatility: D.new("0.05"), expected_return: D.new("0.04")},
      %{volatility: D.new("0.25"), expected_return: D.new("0.15")}
    ]
  }

  assigns = %{frontier: frontier_data}
  html = rendered_to_string(EfficientFrontierChart.render(assigns))

  # Should scale axes to fit data
  assert html =~ "5%"   # Min volatility
  assert html =~ "25%"  # Max volatility
  assert html =~ "4%"   # Min return
  assert html =~ "15%"  # Max return
end
```

### Day 13: Interactive Features

#### Task 3.4.2: Hover & Click Interactions
```elixir
# TEST 66-70: Interactivity
test "shows tooltip on frontier point hover" do
  {:ok, view, _} = live(conn, ~p"/portfolio/optimization")

  # Hover on frontier point
  html = element(view, "[data-point='5']") |> render_hover()

  assert html =~ "Weight A: 65%"
  assert html =~ "Weight B: 35%"
  assert html =~ "Return: 10.2%"
  assert html =~ "Risk: 14.5%"
  assert html =~ "Sharpe: 0.52"
end

test "highlights selected portfolio on click" do
  {:ok, view, _} = live(conn, ~p"/portfolio/optimization")

  # Click frontier point
  view |> element("[data-point='5']") |> render_click()

  html = render(view)
  assert html =~ "selected-portfolio"
  assert html =~ "Rebalancing Preview"
end
```

### Day 14-15: LiveView Integration

#### Task 3.5.1: Optimization LiveView
```elixir
# TEST 71-80: LiveView integration
test "portfolio optimization page loads" do
  {:ok, view, html} = live(conn, ~p"/portfolio/optimization")

  assert html =~ "Portfolio Optimization"
  assert html =~ "Current Holdings"
  assert html =~ "Optimization Settings"
  assert html =~ "Efficient Frontier"
end

test "calculates optimization on form submit" do
  {:ok, view, _} = live(conn, ~p"/portfolio/optimization")

  # Submit optimization form
  view
  |> form("#optimization-form", %{
    "risk_free_rate" => "0.03",
    "target" => "max_sharpe",
    "constraints" => "long_only"
  })
  |> render_submit()

  html = render(view)

  assert html =~ "Optimal Portfolio"
  assert html =~ "Rebalancing Required"
  assert html =~ "Transaction Preview"
end

test "updates frontier when parameters change" do
  {:ok, view, _} = live(conn, ~p"/portfolio/optimization")

  # Change risk-free rate
  view
  |> form("#optimization-form", %{"risk_free_rate" => "0.05"})
  |> render_change()

  html = render(view)

  # Tangency point should move
  assert html =~ "tangency-updated"
end
```

## Week 4: Polish, Documentation & Integration

### Day 16-17: Integration with Existing Analytics

#### Task 3.6.1: AdvancedAnalyticsLive Enhancement
```elixir
# TEST 81-85: Integration tests
test "optimization tab in advanced analytics" do
  {:ok, view, html} = live(conn, ~p"/analytics")

  # Click optimization tab
  view |> element("[data-tab='optimization']") |> render_click()

  html = render(view)
  assert html =~ "Portfolio Optimization"
  assert html =~ "Efficient Frontier"
end

test "shares data with other analytics tabs" do
  {:ok, view, _} = live(conn, ~p"/analytics")

  # Risk metrics should be available
  assert view.assigns.risk_metrics
  assert view.assigns.correlation_matrix

  # Optimization should use same data
  view |> element("[data-tab='optimization']") |> render_click()

  assert view.assigns.optimization_data.assets == view.assigns.positions
end
```

### Day 18: Documentation & Examples

#### Task 3.6.2: Module Documentation
```elixir
# Comprehensive documentation for all modules
defmodule Ashfolio.Portfolio.Optimization.TwoAssetOptimizer do
  @moduledoc """
  Analytical portfolio optimization for two-asset portfolios.

  ## Mathematical Foundation

  Based on Markowitz Mean-Variance Optimization (1952).

  ### Minimum Variance Portfolio

  For two assets with volatilities σ₁, σ₂ and correlation ρ:

      w₁ = (σ₂² - σ₁σ₂ρ) / (σ₁² + σ₂² - 2σ₁σ₂ρ)
      w₂ = 1 - w₁

  ### Portfolio Volatility

      σp = √(w₁²σ₁² + w₂²σ₂² + 2w₁w₂σ₁σ₂ρ)

  ### Maximum Sharpe Ratio (Tangency Portfolio)

  Maximizes: (E[Rp] - Rf) / σp

  ## Examples

      iex> asset_a = %{expected_return: D.new("0.12"), volatility: D.new("0.20")}
      iex> asset_b = %{expected_return: D.new("0.08"), volatility: D.new("0.15")}
      iex> TwoAssetOptimizer.minimum_variance(asset_a, asset_b, D.new("0.3"))
      {:ok, %{weight_a: #Decimal<0.226>, weight_b: #Decimal<0.774>, ...}}

  ## References

  - Markowitz, H. (1952). "Portfolio Selection"
  - Bodie, Kane, Marcus (2021). "Investments" Chapter 7
  - CFA Level III Curriculum (2024). "Portfolio Management"
  """
end
```

### Day 19-20: Final Testing & Performance

#### Task 3.7: End-to-End Testing
```elixir
# TEST 86-100: Complete workflow tests
test "complete optimization workflow" do
  # 1. Load portfolio
  {:ok, portfolio} = Portfolio.get_by_id(portfolio_id)

  # 2. Calculate correlations
  {:ok, correlation_matrix} = CorrelationCalculator.calculate_matrix(portfolio.positions)

  # 3. Run optimization
  {:ok, optimal_weights} = PortfolioOptimizer.optimize(portfolio, correlation_matrix)

  # 4. Generate frontier
  {:ok, frontier} = EfficientFrontier.generate(portfolio.positions)

  # 5. Find tangency portfolio
  {:ok, tangency} = EfficientFrontier.find_tangency(frontier, risk_free_rate)

  # 6. Calculate rebalancing trades
  {:ok, trades} = RebalancingCalculator.calculate_trades(portfolio, optimal_weights)

  # All steps should complete successfully
  assert length(trades) > 0
end

@tag :performance
test "full optimization pipeline < 200ms" do
  {time, _} = :timer.tc(fn ->
    portfolio = generate_test_portfolio(10)
    CorrelationCalculator.calculate_matrix(portfolio.positions)
    PortfolioOptimizer.optimize(portfolio)
    EfficientFrontier.generate(portfolio.positions, points: 20)
  end)

  assert time < 200_000  # microseconds
end
```

## Implementation Modules

```elixir
# lib/ashfolio/portfolio/optimization/
├── two_asset_optimizer.ex           # Core two-asset calculations
├── three_asset_optimizer.ex         # Three-asset extension
├── efficient_frontier.ex            # Frontier generation
├── portfolio_metrics.ex             # Risk/return calculations
├── validation.ex                    # Input validation
└── helpers/
    ├── matrix_helpers.ex            # 3x3 matrix operations
    └── decimal_math.ex              # Decimal sqrt, etc.

# lib/ashfolio_web/live/portfolio_optimization_live/
├── index.ex                         # Main LiveView
├── components/
│   ├── efficient_frontier_chart.ex  # SVG chart component
│   ├── portfolio_weights_table.ex   # Current/optimal comparison
│   ├── optimization_form.ex         # Settings form
│   └── rebalancing_preview.ex       # Trade preview
└── helpers/
    └── chart_scaling.ex             # Data to SVG coordinate mapping

# test/ashfolio/portfolio/optimization/
├── two_asset_optimizer_test.exs     # 30 tests
├── three_asset_optimizer_test.exs   # 10 tests
├── efficient_frontier_test.exs      # 15 tests
├── portfolio_metrics_test.exs       # 10 tests
└── validation_test.exs              # 15 tests

# test/ashfolio_web/live/
└── portfolio_optimization_live_test.exs  # 20 tests
```

## Success Criteria

- [ ] 100+ tests, all passing
- [ ] <10ms two-asset optimization
- [ ] <50ms frontier generation (20 points)
- [ ] <100ms three-asset optimization
- [ ] Interactive frontier visualization
- [ ] Integration with AdvancedAnalyticsLive
- [ ] Comprehensive documentation with formulas
- [ ] Real portfolio rebalancing recommendations

## Next Steps for v0.8.0

With Stage 3 complete, v0.8.0 can build on this foundation:
- Multi-asset optimization (4+ assets) using Nx
- Constraint handling (sector limits, position bounds)
- Black-Litterman model integration
- Factor model optimization
- Tax-aware rebalancing