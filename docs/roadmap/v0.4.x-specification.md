# v0.4.x Financial Planning & Advanced Analytics Specification

**Version**: 2.0  
**Date**: 2025-08-25  
**Target Release**: Q1 2026 (8-10 weeks)  
**Prerequisites**: v0.3.4 Enhanced Analytics completed  
**Status**: IN PROGRESS - v0.4.1 Phase 1A Complete

## ðŸŽ¯ Executive Summary

The v0.4.x series transforms Ashfolio from a reporting tool into a **strategic financial planning platform** by adding retirement planning, goal tracking, and forecasting capabilities while maintaining our local-first SQLite architecture.

### Version Roadmap (SemVer Structure)
- **v0.4.1**: Financial Goals System *(In Progress)*
  - âœ… Goal resource foundation (Complete - 2025-08-25)
  - â³ Emergency fund calculator
  - â³ Goal tracking UI
- **v0.4.2**: Retirement Planning *(Next)*
- **v0.4.3**: Forecasting Engine
- **v0.4.4**: Advanced Analytics
- **v0.4.5**: Benchmark System
- **v0.5.0**: Full Dashboard Integration

### Core Value Proposition
- **Retirement Planning**: Industry-standard calculations (25x rule, 4% withdrawal)
- **Financial Goals**: Emergency fund, retirement, custom savings targets
- **Long-term Forecasting**: Growth projections with configurable assumptions
- **Professional Analytics**: Time-weighted returns, benchmarking, rolling returns

## ðŸ“‹ Feature Specifications

### 1. Retirement Planning Tools ðŸŽ¯

#### 1.1 25x Expenses Calculation
```elixir
# Core calculation engine
defmodule Ashfolio.FinancialManagement.RetirementCalculator do
  @doc """
  Calculates retirement target using 25x annual expenses rule
  Based on 4% safe withdrawal rate assumption
  """
  def calculate_retirement_target(annual_expenses) do
    Decimal.mult(annual_expenses, Decimal.new("25"))
  end
end
```

**User Stories**:
- As a user, I can see my retirement target based on current expenses
- As a user, I can adjust my target expenses for retirement planning
- As a user, I can track progress toward my 25x goal

**Acceptance Criteria**:
- Calculate 25x target from last 12 months of expenses
- Allow manual override of target annual expenses
- Display progress as percentage and dollar amount
- Show time to goal based on current savings rate

#### 1.2 4% Withdrawal Rate Planning
```elixir
def calculate_safe_withdrawal(portfolio_value) do
  Decimal.mult(portfolio_value, Decimal.new("0.04"))
end

def calculate_withdrawal_readiness(portfolio_value, annual_expenses) do
  safe_withdrawal = calculate_safe_withdrawal(portfolio_value)
  Decimal.compare(safe_withdrawal, annual_expenses)
end
```

**User Stories**:
- As a user, I can see if my current portfolio supports my expenses
- As a user, I can model different withdrawal scenarios
- As a user, I can plan for early retirement feasibility

**Acceptance Criteria**:
- Calculate 4% withdrawal from current portfolio value
- Compare against current/target annual expenses
- Display readiness status (ready/not ready/years remaining)
- Show monthly safe withdrawal amount

#### 1.3 Dividend Income Projections
```elixir
# Calculate forward dividend income for retirement planning
def project_dividend_income(holdings, growth_rate \\ Decimal.new("0.03")) do
  holdings
  |> Enum.map(&calculate_holding_dividend_projection(&1, growth_rate))
  |> Enum.reduce(Decimal.new("0"), &Decimal.add/2)
end
```

**User Stories**:
- As a user, I can see projected dividend income from current holdings
- As a user, I can model dividend growth over time
- As a user, I can plan for dividend-focused retirement strategy

**Acceptance Criteria**:
- Calculate current annual dividend income from portfolio
- Project future dividend income with configurable growth rates
- Display monthly dividend income for retirement planning
- Compare dividend income to target expenses

### 2. Financial Goal Setting ðŸŽ¯

#### 2.1 Goal Resource Architecture
```elixir
defmodule Ashfolio.FinancialManagement.FinancialGoal do
  @moduledoc """
  Financial goal tracking resource following Expense.ex patterns.
  
  Enables goal setting, progress tracking, and timeline calculations
  for emergency funds, retirement planning, and custom savings goals.
  """
  
  use Ash.Resource,
    domain: Ashfolio.FinancialManagement,
    data_layer: AshSqlite.DataLayer

  # Follow existing patterns from expense.ex:14-16
  sqlite do
    table("financial_goals")
    repo(Ashfolio.Repo)
  end

  attributes do
    uuid_primary_key(:id)
    
    attribute :name, :string do
      allow_nil?(false)
      description("Name of the financial goal")
    end
    
    attribute :target_amount, :decimal do
      allow_nil?(false)
      description("Target amount to achieve")
    end
    
    attribute :current_amount, :decimal do
      default(Decimal.new("0"))
      allow_nil?(false)
      description("Current progress toward goal")
    end
    
    attribute :target_date, :date do
      description("Target completion date")
    end
    
    attribute :goal_type, :atom do
      constraints(one_of: [:emergency_fund, :retirement, :house_down_payment, :vacation, :custom])
      allow_nil?(false)
      description("Type of financial goal")
    end
    
    attribute :monthly_contribution, :decimal do
      description("Planned monthly contribution")
    end
    
    attribute :is_active, :boolean do
      default(true)
      allow_nil?(false)
      description("Whether goal is actively being tracked")
    end
    
    timestamps()
  end

  # Follow validation patterns from expense.ex:70-103
  validations do
    validate(present(:name), message: "is required")
    validate(present(:target_amount), message: "is required")
    validate(present(:goal_type), message: "is required")
    
    # Validate amounts are positive
    validate(compare(:target_amount, greater_than: 0),
      message: "must be greater than 0"
    )
    
    validate(compare(:current_amount, greater_than_or_equal_to: 0),
      message: "cannot be negative"
    )
    
    # Validate reasonable limits
    validate(compare(:target_amount, less_than_or_equal_to: Decimal.new("10000000.00")),
      message: "cannot exceed $10,000,000.00"
    )
    
    validate(string_length(:name, min: 1, max: 200))
  end

  # Follow action patterns from expense.ex:106-169
  actions do
    defaults([:read, :destroy])

    create :create do
      accept([:name, :target_amount, :current_amount, :target_date, 
              :goal_type, :monthly_contribution, :is_active])
      primary?(true)
    end

    update :update do
      accept([:name, :target_amount, :current_amount, :target_date, 
              :monthly_contribution, :is_active])
      primary?(true)
      require_atomic?(false)
    end

    read :active do
      filter(expr(is_active == true))
    end

    read :by_type do
      argument(:goal_type, :atom, allow_nil?: false)
      filter(expr(goal_type == ^arg(:goal_type)))
    end
  end

  calculations do
    calculate :progress_percentage, :decimal, expr(
      fragment("CASE WHEN ? > 0 THEN (? / ? * 100) ELSE 0 END",
        target_amount, current_amount, target_amount)
    )
    
    calculate :months_to_goal, :integer, expr(
      fragment("CASE WHEN ? > 0 AND ? > ? THEN CAST((? - ?) / ? AS INTEGER) ELSE NULL END",
        monthly_contribution, target_amount, current_amount,
        target_amount, current_amount, monthly_contribution)
    )
    
    calculate :amount_remaining, :decimal, expr(
      fragment("CASE WHEN ? > ? THEN (? - ?) ELSE 0 END",
        target_amount, current_amount, target_amount, current_amount)
    )
  end

  # Follow code_interface pattern from expense.ex:175-219
  code_interface do
    domain(Ashfolio.FinancialManagement)
    
    define(:create, action: :create)
    define(:list, action: :read)
    define(:get_by_id, action: :read, get_by: [:id])
    define(:update, action: :update)
    define(:destroy, action: :destroy)
    define(:active, action: :active)
    define(:by_type, action: :by_type, args: [:goal_type])
  end
end
```

#### 2.2 Emergency Fund Calculator
```elixir
def calculate_emergency_fund_target(monthly_expenses, months \\ 6) do
  Decimal.mult(monthly_expenses, Decimal.new(to_string(months)))
end
```

**User Stories**:
- As a user, I can set an emergency fund goal based on my expenses
- As a user, I can track progress toward my emergency fund
- As a user, I can adjust my emergency fund target (3-12 months expenses)

**Acceptance Criteria**:
- Default emergency fund to 6 months of expenses
- Allow customization of month multiplier (3, 6, 9, 12 months)
- Track current emergency fund balance
- Show monthly contribution needed to reach goal by target date

#### 2.3 Custom Savings Goals
**User Stories**:
- As a user, I can create custom financial goals (vacation, car, etc.)
- As a user, I can set target amounts and dates for my goals
- As a user, I can track multiple goals simultaneously

**Acceptance Criteria**:
- Create, edit, delete custom financial goals
- Set target amount, target date, and monthly contribution
- Display progress dashboard for all active goals
- Calculate time to goal based on contribution rate

### 3. Long-term Forecasting ðŸ“ˆ

#### 3.1 Growth Projection Engine
```elixir
defmodule Ashfolio.FinancialManagement.ForecastCalculator do
  @doc """
  Projects portfolio growth with configurable assumptions
  """
  def project_portfolio_growth(current_value, annual_contribution, years, growth_rate) do
    # Compound growth calculation with regular contributions
    # Future Value of Annuity + Future Value of Present Value
    
    monthly_rate = Decimal.div(growth_rate, Decimal.new("12"))
    months = years * 12
    monthly_contribution = Decimal.div(annual_contribution, Decimal.new("12"))
    
    # Calculate using compound interest formulas
    calculate_compound_growth(current_value, monthly_contribution, monthly_rate, months)
  end
end
```

**User Stories**:
- As a user, I can project my portfolio value over 10-30 years
- As a user, I can adjust growth rate assumptions (5%, 7%, 10%)
- As a user, I can model different contribution scenarios

**Acceptance Criteria**:
- Project portfolio growth with configurable parameters
- Default assumptions: 7% annual growth, current contribution rate
- Display projections for 5, 10, 15, 20, 25, 30 years
- Show impact of different growth rates and contribution amounts

#### 3.2 Scenario Planning
**User Stories**:
- As a user, I can compare optimistic/realistic/pessimistic scenarios
- As a user, I can see the impact of increasing my contributions
- As a user, I can model early retirement scenarios

**Acceptance Criteria**:
- Provide three standard scenarios (5%, 7%, 10% growth)
- Allow custom scenario creation
- Display side-by-side scenario comparisons
- Calculate years to financial independence under each scenario

### 4. Advanced Portfolio Analytics ðŸ“Š

#### 4.1 Time-Weighted Return (TWR)
```elixir
defmodule Ashfolio.Portfolio.PerformanceCalculator do
  @doc """
  Calculate Time-Weighted Return - industry standard performance metric
  """
  def calculate_time_weighted_return(transactions, current_values) do
    # Break into sub-periods based on cash flows
    # Calculate return for each sub-period
    # Compound the sub-period returns
    periods = break_into_periods(transactions)
    
    periods
    |> Enum.map(&calculate_period_return/1)
    |> compound_returns()
  end
end
```

**User Stories**:
- As a user, I can see my portfolio's time-weighted return
- As a user, I can compare my performance to standard metrics
- As a user, I can see performance excluding the impact of my contributions

**Acceptance Criteria**:
- Calculate TWR for 1-year, 3-year, 5-year periods
- Display annualized returns
- Handle periods with multiple cash flows correctly
- Show period-by-period performance breakdown

#### 4.2 Money-Weighted Return (MWR)
```elixir
def calculate_money_weighted_return(cash_flows, current_value) do
  # Follow error handling pattern from calculator.ex:28-44
  case validate_cash_flows(cash_flows, current_value) do
    :ok ->
      Logger.debug("Calculating MWR for #{length(cash_flows)} cash flows")
      
      case calculate_irr_newton_raphson(cash_flows, current_value) do
        {:ok, rate} -> {:ok, rate}
        {:error, :no_convergence} -> 
          # Fallback to bisection method
          calculate_irr_bisection(cash_flows, current_value)
        {:error, reason} -> 
          Logger.warning("MWR calculation failed: #{inspect(reason)}")
          {:error, reason}
      end
    
    {:error, reason} ->
      Logger.warning("Invalid MWR inputs: #{inspect(reason)}")
      {:error, reason}
  end
end

defp calculate_irr_newton_raphson(cash_flows, current_value, initial_guess \\ 0.1) do
  # Newton-Raphson method for IRR calculation
  # Max 100 iterations, tolerance 0.0001
  # Handle edge cases: all negative flows, zero current value
  iterate_newton_raphson(cash_flows, current_value, initial_guess, 0, 100, 0.0001)
end

defp calculate_irr_bisection(cash_flows, current_value) do
  # Bisection method fallback
  # Range: -0.99 to 10.0 (reasonable IRR bounds)
  bisection_search(cash_flows, current_value, -0.99, 10.0, 0.0001, 100)
end
```

**User Stories**:
- As a user, I can see my personal return rate (MWR)
- As a user, I can understand how contribution timing affected my returns
- As a user, I can see the difference between TWR and MWR

**Acceptance Criteria**:
- Calculate MWR using IRR methodology
- Display for multiple time periods
- Compare MWR vs TWR in analytics dashboard
- Explain the difference in user-friendly terms

#### 4.3 Benchmark Comparisons
```elixir
# Store benchmark data locally (updated manually or via import)
defmodule Ashfolio.Portfolio.Benchmark do
  use Ash.Resource

  attributes do
    attribute :name, :string  # "S&P 500", "Total Stock Market", etc.
    attribute :symbol, :string  # "^GSPC", "VTI"
    attribute :return_1yr, :decimal
    attribute :return_3yr, :decimal
    attribute :return_5yr, :decimal
    attribute :as_of_date, :date
  end
end
```

**User Stories**:
- As a user, I can compare my portfolio to S&P 500 performance
- As a user, I can see if I'm outperforming or underperforming benchmarks
- As a user, I can track relative performance over time

**Acceptance Criteria**:
- Compare portfolio returns to major indices (S&P 500, Total Market)
- Display outperformance/underperformance clearly
- Show benchmark comparison charts
- Allow manual update of benchmark data

#### 4.4 Rolling Returns Analysis
```elixir
def calculate_rolling_returns(performance_data, period_months) do
  performance_data
  |> Enum.chunk_every(period_months, 1, :discard)
  |> Enum.map(&calculate_period_return/1)
end
```

**User Stories**:
- As a user, I can see 1-year rolling returns over time
- As a user, I can identify periods of strong/weak performance
- As a user, I can understand portfolio volatility patterns

**Acceptance Criteria**:
- Calculate 1-year, 3-year rolling returns
- Display rolling return charts
- Highlight best/worst rolling periods
- Show volatility metrics (standard deviation)

#### 4.5 Asset Class Breakdown
**User Stories**:
- As a user, I can see my portfolio allocation by asset class
- As a user, I can track changes in allocation over time
- As a user, I can identify concentration risks

**Acceptance Criteria**:
- Categorize holdings by asset class (stocks, bonds, REITs, etc.)
- Display allocation pie charts and trend analysis
- Track allocation drift over time
- Identify overconcentration in single assets/sectors

## ðŸ¤– AI Implementation Notes

### Existing Patterns to Follow

**Resource Structure**: Follow `lib/ashfolio/financial_management/expense.ex` pattern
- Attributes with validation (lines 70-103)
- Code interface structure (lines 175-219)  
- Decimal constraints and error messages
- Calculation helpers using Decimal operations

**Calculator Modules**: Follow `lib/ashfolio/portfolio/calculator.ex` pattern
- Logger.debug calls for monitoring (lines 29, 38)
- Error handling with {:ok, result} | {:error, reason} tuples
- Decimal arithmetic throughout all calculations
- Documentation with @doc and examples

**LiveView Integration**: Extend `lib/ashfolio_web/live/dashboard_live.ex`
- PubSub subscriptions: "accounts", "transactions", "net_worth" (line 25)
- Real-time updates using handle_info callbacks
- Widget integration in render function
- Event handling patterns for user interactions

**Test Organization**: Follow `docs/TESTING_STRATEGY.md` patterns
- Unit tests: @tag :unit for pure calculations
- Integration tests: @tag :integration for database operations
- Performance tests: @tag :performance for large datasets
- Maintain 100% test coverage standard

### Code Quality Requirements

- Use existing error handling: `put_flash/3` for user messages
- Follow Decimal formatting conventions from existing code
- Use validation message patterns from Expense resource
- Follow PubSub topic naming: accounts, transactions, financial_goals
- Extend `core_components.ex` for new UI widgets

### Integration Points

**Context API**: Cross-domain operations between Portfolio and FinancialManagement
**Database**: SQLite with AshSqlite.DataLayer (follow existing resource patterns)
**Charts**: Contex integration (existing patterns in dashboard components)
**Caching**: ETS cache following `lib/ashfolio/cache.ex` patterns

## ðŸ—ï¸ Technical Architecture

### Database Schema with Performance Indexes

```sql
-- Financial Goals (follow existing migration patterns)
CREATE TABLE financial_goals (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  target_amount DECIMAL NOT NULL,
  current_amount DECIMAL DEFAULT 0,
  target_date DATE,
  goal_type TEXT CHECK (goal_type IN ('emergency_fund', 'retirement', 'house_down_payment', 'vacation', 'custom')),
  monthly_contribution DECIMAL,
  is_active BOOLEAN DEFAULT TRUE,
  inserted_at DATETIME,
  updated_at DATETIME
);

-- Performance indexes for goal queries
CREATE INDEX idx_financial_goals_active ON financial_goals(is_active) WHERE is_active = 1;
CREATE INDEX idx_financial_goals_type ON financial_goals(goal_type);
CREATE INDEX idx_financial_goals_target_date ON financial_goals(target_date);

-- Benchmark Data
CREATE TABLE benchmarks (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  symbol TEXT UNIQUE,
  return_1yr DECIMAL,
  return_3yr DECIMAL,
  return_5yr DECIMAL,
  as_of_date DATE,
  inserted_at DATETIME,
  updated_at DATETIME
);

-- Benchmark lookup indexes
CREATE INDEX idx_benchmarks_symbol ON benchmarks(symbol);
CREATE INDEX idx_benchmarks_date ON benchmarks(as_of_date DESC);

-- Portfolio Performance Cache (follow cache.ex patterns)
CREATE TABLE performance_cache (
  id TEXT PRIMARY KEY,
  calculation_type TEXT, -- 'twr', 'mwr', 'rolling_return'
  period_months INTEGER,
  value DECIMAL,
  as_of_date DATE,
  calculated_at DATETIME,
  cache_key TEXT -- For ETS integration
);

-- Performance cache lookup indexes
CREATE INDEX idx_performance_cache_lookup ON performance_cache(calculation_type, period_months, as_of_date DESC);
CREATE INDEX idx_performance_cache_key ON performance_cache(cache_key);
CREATE INDEX idx_performance_cache_staleness ON performance_cache(calculated_at DESC);
```

### Performance Cache Implementation

```elixir
# Follow lib/ashfolio/cache.ex patterns
defmodule Ashfolio.FinancialManagement.PerformanceCache do
  @moduledoc """
  ETS-based cache for expensive financial calculations.
  
  Follows existing cache patterns with TTL and invalidation support.
  """
  
  use GenServer
  require Logger

  @cache_table :performance_cache
  @default_ttl 3600 # 1 hour in seconds

  def start_link(_opts) do
    GenServer.start_link(__MODULE__, [], name: __MODULE__)
  end

  def init(_) do
    :ets.new(@cache_table, [:set, :public, :named_table])
    {:ok, %{}}
  end

  @doc """
  Get cached performance calculation.
  Key pattern: "twr:account_id:period_months" or "mwr:account_id:period_months"
  """
  def get(calculation_type, period_months, account_id \\ "global") do
    key = "#{calculation_type}:#{account_id}:#{period_months}"
    
    case :ets.lookup(@cache_table, key) do
      [{^key, value, expires_at}] ->
        if :os.system_time(:second) < expires_at do
          {:ok, value}
        else
          :ets.delete(@cache_table, key)
          :miss
        end
      [] -> 
        :miss
    end
  end

  @doc """
  Cache performance calculation result with TTL
  """
  def put(calculation_type, period_months, value, account_id \\ "global", ttl \\ @default_ttl) do
    key = "#{calculation_type}:#{account_id}:#{period_months}"
    expires_at = :os.system_time(:second) + ttl
    
    :ets.insert(@cache_table, {key, value, expires_at})
    Logger.debug("Cached performance calculation: #{key}")
    :ok
  end

  @doc """
  Invalidate cache on new transactions (follow PubSub patterns)
  """
  def invalidate_account_cache(account_id) do
    # Remove all cached calculations for specific account
    :ets.match_delete(@cache_table, {"_:" <> account_id <> ":_", :_, :_})
    Logger.debug("Invalidated performance cache for account: #{account_id}")
  end
end
```

### Performance Considerations

- **Caching Strategy**: Pre-calculate expensive metrics (TWR, MWR) and cache results
- **Background Jobs**: Use Oban for complex calculations that can run asynchronously
- **Incremental Updates**: Only recalculate performance when new transactions are added
- **Database Indexes**: Optimize queries for time-series performance data

### UI Architecture

```elixir
# New LiveView modules
- AshfolioWeb.FinancialPlanningLive.Index     # Main planning dashboard
- AshfolioWeb.FinancialPlanningLive.Goals     # Goal management
- AshfolioWeb.FinancialPlanningLive.Retirement # Retirement planning
- AshfolioWeb.FinancialPlanningLive.Forecast  # Growth projections
- AshfolioWeb.Portfolio.AdvancedAnalytics     # Professional analytics
```

## ðŸ“Š Success Metrics

### Development Success Criteria
- [ ] All financial planning calculations accurate to 2 decimal places
- [ ] Performance analytics match industry standard methodologies
- [ ] Goal tracking updates in real-time as portfolio changes
- [ ] Forecasting scenarios display results in <2 seconds
- [ ] All features work offline (local-first architecture maintained)

### User Experience Goals
- Set financial goals in <60 seconds
- Understand retirement readiness immediately
- Compare portfolio performance to benchmarks easily
- Project financial independence timeline clearly
- Access all planning tools without external dependencies

### Performance Benchmarks
- Goal calculations: <100ms
- TWR/MWR calculations: <500ms for 5 years of data
- Forecasting projections: <1 second for 30-year analysis
- Dashboard load: <2 seconds with all widgets

## ðŸ§ª AI-Ready Testing Strategy

### Unit Tests (@tag :unit)
**Follow existing patterns from `docs/TESTING_STRATEGY.md`**

```elixir
# Financial calculation accuracy tests
@tag :unit
@tag :smoke
test "calculates 25x retirement target correctly" do
  annual_expenses = Decimal.new("50000")
  expected = Decimal.new("1250000")
  
  assert {:ok, ^expected} = RetirementCalculator.calculate_retirement_target(annual_expenses)
end

@tag :unit
test "handles edge cases in MWR calculation" do
  # Test zero cash flows
  assert {:error, "insufficient_data"} = PerformanceCalculator.calculate_money_weighted_return([], Decimal.new("1000"))
  
  # Test all negative cash flows
  negative_flows = [Decimal.new("-100"), Decimal.new("-100")]
  assert {:error, _reason} = PerformanceCalculator.calculate_money_weighted_return(negative_flows, Decimal.new("0"))
end
```

### Integration Tests (@tag :integration)
**Follow existing database test patterns**

```elixir
# Goal CRUD operations with database
@tag :integration
test "creates financial goal with validations" do
  # Reset global account balances in setup (see TESTING_STRATEGY.md:37)
  goal_attrs = %{
    name: "Emergency Fund",
    target_amount: Decimal.new("25000"),
    goal_type: :emergency_fund
  }
  
  assert {:ok, goal} = FinancialGoal.create(goal_attrs)
  assert goal.name == "Emergency Fund"
  assert Decimal.equal?(goal.target_amount, Decimal.new("25000"))
end

# LiveView interactions
@tag :integration
test "goal progress updates in real-time" do
  # Test PubSub integration following existing patterns
  # Verify dashboard updates when goals change
end
```

### LiveView Tests (@tag :liveview)
**Follow existing LiveView test patterns**

```elixir
@tag :liveview
test "financial planning dashboard loads with widgets" do
  {:ok, view, html} = live(conn, "/financial_planning")
  
  assert html =~ "Financial Goals"
  assert html =~ "Retirement Planning"
  assert html =~ "Portfolio Projections"
end

@tag :liveview
test "goal creation form submits successfully" do
  {:ok, view, _html} = live(conn, "/financial_planning/goals")
  
  view
  |> form("#goal-form", goal: %{
    name: "Vacation Fund",
    target_amount: "5000",
    goal_type: "vacation"
  })
  |> render_submit()
  
  assert_redirect(view, "/financial_planning/goals")
  flash = assert_redirected(view, "/financial_planning/goals")
  assert flash =~ "Goal created successfully"
end
```

### Performance Tests (@tag :performance)
**Follow existing performance test patterns**

```elixir
@tag :performance
test "TWR calculation handles large datasets efficiently" do
  # Generate 5 years of daily transaction data (1825 records)
  transactions = generate_large_transaction_set(1825)
  
  {time_us, {:ok, _result}} = :timer.tc(fn ->
    PerformanceCalculator.calculate_time_weighted_return(transactions, current_values)
  end)
  
  # Should complete within 500ms benchmark (see line 632 in spec)
  assert time_us < 500_000, "TWR calculation took #{time_us}Î¼s, exceeds 500ms limit"
end

@tag :performance
test "financial goal dashboard loads within performance benchmark" do
  # Create 50 active goals to test UI performance
  goals = create_multiple_goals(50)
  
  {time_us, {:ok, _view, _html}} = :timer.tc(fn ->
    live(conn, "/financial_planning")
  end)
  
  # Should load within 2 seconds (see line 634 in spec)
  assert time_us < 2_000_000, "Dashboard load took #{time_us}Î¼s, exceeds 2s limit"
end
```

### Test Data Patterns
**Follow `docs/testing/global-test-data-requirements.md`**

```elixir
# Use global test data when possible for unit tests
def sample_cash_flows do
  [
    %{date: ~D[2023-01-01], amount: Decimal.new("-10000")}, # Initial investment
    %{date: ~D[2023-06-01], amount: Decimal.new("-5000")},  # Additional contribution
    %{date: ~D[2023-12-31], amount: Decimal.new("18000")}   # Current value
  ]
end

# Reset global account balances for integration tests
setup do
  # Clear any existing test data
  Ash.Seed.seed!(FinancialGoal, [])
  :ok
end
```

### Success Criteria
- **Unit Tests**: 100% coverage on financial calculations
- **Integration Tests**: All CRUD operations and PubSub updates working
- **LiveView Tests**: All user workflows functional  
- **Performance Tests**: All calculations meet benchmarks (lines 630-634 in spec)
- **Test Suite Speed**: Standard tests complete in <30 seconds
- **CI Pipeline**: All test stages pass consistently

## ðŸ“¦ Version Breakdown (SemVer Structure)

### v0.4.1 - Financial Goals System
**Deliverable**: Complete financial goal management with UI
- **Phase 1A** âœ…: Goal resource foundation (Complete)
- **Phase 1B**: Emergency fund calculator & expense integration
- **Phase 1C**: Goal tracking UI & dashboard widgets
- **Phase 1D**: Real-time updates via PubSub

### v0.4.2 - Retirement Planning
**Deliverable**: Industry-standard retirement calculations
- 25x expenses rule implementation
- 4% safe withdrawal rate analysis
- Dividend income projections
- Retirement readiness dashboard
- Integration with portfolio data

### v0.4.3 - Forecasting Engine
**Deliverable**: Long-term growth projections
- Compound growth calculator with contributions
- Scenario planning (5%, 7%, 10% growth rates)
- Interactive forecasting charts (Contex)
- Contribution impact analysis
- Time-to-goal calculations

### v0.4.4 - Advanced Analytics
**Deliverable**: Professional portfolio analytics
- Time-weighted return (TWR) calculations
- Money-weighted return (MWR) with IRR
- Rolling returns analysis
- Performance caching with ETS
- Period-by-period breakdown

### v0.4.5 - Benchmark System
**Deliverable**: Portfolio comparison tools
- Benchmark data management
- S&P 500 and Total Market comparisons
- Outperformance/underperformance tracking
- Asset class allocation analysis
- Concentration risk identification

### v0.5.0 - Dashboard Integration (Minor Version)
**Deliverable**: Complete financial planning platform
- Full dashboard widget integration
- Performance optimization
- User experience refinement
- Documentation completion
- Production readiness

## ðŸ“… AI-Optimized Implementation Timeline

### Phase 1A: Goal Foundation (1.5 weeks) âœ… COMPLETE
**Deliverable**: Core FinancialGoal resource with CRUD operations

1.1 **FinancialGoal Resource** (3 days) âœ…
   - Follow `expense.ex` pattern exactly (lines 94-235 in spec)
   - Copy validation structure from `expense.ex:70-103`
   - Test with existing test patterns (@tag :unit, :integration)
   - **Implemented**: `lib/ashfolio/financial_management/financial_goal.ex`

1.2 **Database Migration** (1 day) âœ…
   - Create migration following existing patterns in `priv/repo/migrations/`
   - Add performance indexes (lines 517-519 in spec)
   - Test migration rollback
   - **Implemented**: `priv/repo/migrations/20250825_create_financial_goals_table.exs`

1.3 **Domain Integration** (1 day) âœ…
   - Add to `FinancialManagement` domain (line 17 pattern)
   - Test domain loading with existing patterns
   - Verify PubSub integration
   - **Implemented**: Resource registered in `lib/ashfolio/financial_management.ex`

**Success Criteria**: âœ… FinancialGoal CRUD working, tests passing (15 tests), domain integrated

### Phase 1B: Basic Goals & Emergency Fund (1 week)
**Deliverable**: Emergency fund calculator and goal tracking

1.4 **Emergency Fund Calculator** (2 days)
   - Use `expense.ex` aggregation patterns (lines 189-218)
   - Follow `Calculator.ex` error handling (lines 28-44)
   - Test with various scenarios

1.5 **Goal Progress Tracking** (2 days)
   - Implement calculations in FinancialGoal resource
   - Real-time updates via PubSub ("financial_goals" topic)
   - Basic UI components following `core_components.ex`

1.6 **Integration Testing** (1 day)
   - Test goal creation, updates, progress calculation
   - Verify real-time updates work
   - Performance testing with multiple goals

**Success Criteria**: Emergency fund goals working, progress tracking accurate, UI responsive

### Phase 2: Retirement Planning (1.5 weeks)
**Deliverable**: 25x rule, 4% withdrawal, dividend projections

2.1 **RetirementCalculator Module** (3 days)
   - Follow `Calculator.ex` structure and patterns
   - 25x expenses using expense aggregation functions
   - Error handling with Logger.debug calls

2.2 **Withdrawal Analysis** (2 days)
   - 4% rule calculations with portfolio integration
   - Readiness status logic and validation
   - Edge case handling (zero portfolio, negative expenses)

2.3 **Dividend Projections** (2 days)
   - Integration with existing portfolio data
   - Growth rate modeling with Decimal precision
   - Caching for performance

**Success Criteria**: Retirement calculations accurate, integrated with portfolio data

### Phase 3: Forecasting Engine (1.5 weeks)
**Deliverable**: Growth projections and scenario planning

3.1 **ForecastCalculator Module** (4 days)
   - Compound growth calculations using Decimal
   - Multiple scenario support (5%, 7%, 10%)
   - Performance optimization for 30-year projections

3.2 **Chart Integration** (2 days)
   - Contex charts following existing dashboard patterns
   - Interactive scenario comparisons
   - Responsive design with existing component styles

**Success Criteria**: Forecasting accurate, charts responsive, scenarios comparable

### Phase 4A: Basic Analytics (1 week)
**Deliverable**: Enhanced portfolio analytics foundation

4.1 **Performance Foundation** (3 days)
   - Extend existing `Calculator.ex` with time-period returns
   - Asset allocation breakdown
   - Basic benchmark data structure

4.2 **Benchmark System** (2 days)
   - Benchmark resource following FinancialGoal patterns
   - Manual data entry UI
   - Comparison calculations

**Success Criteria**: Basic performance metrics working, benchmarks functional

### Phase 4B: Advanced Analytics (2 weeks)
**Deliverable**: TWR, MWR, rolling returns

4.3 **TWR Implementation** (4 days)
   - Time-weighted return algorithm
   - Period breakdown logic
   - Caching with PerformanceCache (lines 558-621 in spec)

4.4 **MWR Implementation** (4 days)
   - IRR calculation with Newton-Raphson method (lines 369-380 in spec)
   - Bisection fallback for non-convergence
   - Extensive edge case testing

4.5 **Rolling Returns** (2 days)
   - Rolling calculation implementation
   - Chart visualization with performance data
   - Volatility metrics

**Success Criteria**: Advanced metrics match industry standards, performance optimized

### Phase 5: Integration & Polish (1 week)
**Deliverable**: Complete integration with dashboard

5.1 **Dashboard Integration** (3 days)
   - Extend `DashboardLive` with financial planning widgets
   - PubSub subscriptions for real-time updates
   - Widget layout and responsive design

5.2 **Performance Optimization** (2 days)
   - ETS cache implementation and tuning
   - Database query optimization verification
   - Load testing with realistic datasets

5.3 **Documentation & Testing** (2 days)
   - Complete test coverage verification
   - Update documentation following style guide
   - User experience testing and refinement

**Success Criteria**: All features integrated, performance benchmarks met, 100% test coverage

## ðŸ”’ Risk Mitigation

### Technical Risks
1. **Complex Financial Calculations**: Validate against industry standards and third-party tools
2. **Performance with Large Datasets**: Implement caching and background processing
3. **Accuracy Requirements**: Use Decimal arithmetic throughout, comprehensive testing

### Mitigation Strategies
- Phase delivery allows for early feedback and course correction
- Extensive unit testing for all financial calculations
- Performance monitoring and optimization throughout development
- Feature flags for gradual rollout

## âœ… Completion Criteria

### v0.4.1 - Financial Goals
- [x] FinancialGoal resource foundation implemented and tested
- [ ] Emergency fund calculator integrated with expenses
- [ ] Goal tracking UI with dashboard widgets
- [ ] Real-time updates via PubSub working
- [ ] All tests passing, documentation complete

### v0.4.2 - Retirement Planning
- [ ] 25x expenses calculator implemented
- [ ] 4% withdrawal rate analysis working
- [ ] Dividend income projections accurate
- [ ] Retirement dashboard integrated
- [ ] Portfolio data fully integrated

### v0.4.3 - Forecasting Engine
- [ ] Compound growth calculations accurate
- [ ] Scenario planning with multiple rates
- [ ] Interactive charts implemented
- [ ] Performance meets <1 second for 30-year projections

### v0.4.4 - Advanced Analytics
- [ ] TWR calculations match industry standards
- [ ] MWR/IRR algorithms working correctly
- [ ] Rolling returns analysis functional
- [ ] Performance cache implemented with ETS

### v0.4.5 - Benchmark System
- [ ] Benchmark data management working
- [ ] Comparison charts functional
- [ ] Asset allocation analysis complete

### v0.5.0 - Overall Completion
- [ ] All v0.4.x features integrated in dashboard
- [ ] Performance benchmarks met across all calculations
- [ ] Documentation complete for all features
- [ ] 100% test coverage maintained
- [ ] User acceptance testing confirms intuitive workflow

## ðŸ“ Implementation Notes

### Phase 1A: Goal Foundation (Completed 2025-08-25)

**Key Implementation Decisions**:
- Used **Decimal** type for monetary amounts (consistency with existing Expense resource)
- Kept schema simple: no soft delete, no relationships to accounts/categories
- Used Ash constraints for goal types instead of DB CHECK constraints
- Added comprehensive helper functions: `goal_progress_summary!()`, `emergency_fund_status!()`

**Files Created**:
- `lib/ashfolio/financial_management/financial_goal.ex` (210 lines)
- `priv/repo/migrations/20250825_create_financial_goals_table.exs`
- `test/ashfolio/financial_management/financial_goal_test.exs` (15 tests, 100% passing)

**Performance**: All 1043 tests passing (including 15 new FinancialGoal tests)

---

**This specification provides a comprehensive, production-ready roadmap for v0.4.0 that maintains Ashfolio's local-first architecture while delivering professional-grade financial planning capabilities.**