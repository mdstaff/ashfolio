# v0.3.x TDD Specification: Frontend Components & UX

Version: 1.0  
Date: 2025-08-20  
Status: Ready for Implementation  
Current Target: v0.3.1 - Frontend Components (2 weeks, Late Q4 2025)

## Overview

This specification covers TDD requirements for the v0.3.x frontend development series. v0.3.1 completes the v0.3.0 vision by delivering polished frontend components and user experience for expense tracking and net worth analytics. With the rock-solid backend foundation established in v0.3.0, this series focuses entirely on test-driven LiveView component development and Contex chart integration.

Future v0.3.x releases can reference and extend these TDD patterns for additional frontend features.

## Architecture Foundation (Already Complete)

âœ… Backend Resources Ready:

- `Expense` resource with CRUD operations, 14 passing tests
- `NetWorthSnapshot` resource with analytics functions
- `NetWorthCalculator` with optimized performance
- Oban background jobs configured and ready
- Database migrations with proper indexes

## TDD Implementation Approach

### Test-First Development Workflow

1. RED: Write failing component test
2. GREEN: Implement minimal code to pass
3. REFACTOR: Clean up with tests passing
4. INTEGRATE: Verify with browser automation

## Feature 1: ExpenseLive CRUD Interface

### Test-Driven Requirements

#### 1.1 Expense List View Tests

```elixir
# test/ashfolio_web/live/expense_live/index_test.exs
defmodule AshfolioWeb.ExpenseLive.IndexTest do
  use AshfolioWeb.ConnCase, async: false
  import Phoenix.LiveViewTest

  describe "expense index" do
    setup do
      # Reset account balances for clean test state
      require Ash.Query

      Ashfolio.Portfolio.Account
      |> Ash.Query.for_read(:read)
      |> Ash.read!()
      |> Enum.each(fn account ->
        Ashfolio.Portfolio.Account.update(account, %{balance: Decimal.new("0.00")})
      end)

      # Create test expense data
      {:ok, checking_account} = Ashfolio.Portfolio.Account.create(%{
        name: "Test Checking",
        account_type: :checking,
        balance: Decimal.new("5000.00")
      })

      {:ok, category} = Ashfolio.FinancialManagement.TransactionCategory.create(%{
        name: "Groceries",
        color: "#4CAF50"
      })

      {:ok, expense1} = Ashfolio.FinancialManagement.Expense.create(%{
        description: "Weekly groceries",
        amount: Decimal.new("125.50"),
        date: ~D[2024-08-15],
        merchant: "Whole Foods",
        category_id: category.id,
        account_id: checking_account.id
      })

      {:ok, expense2} = Ashfolio.FinancialManagement.Expense.create(%{
        description: "Gas station",
        amount: Decimal.new("45.20"),
        date: ~D[2024-08-10],
        merchant: "Shell",
        category_id: category.id,
        account_id: checking_account.id
      })

      %{checking_account: checking_account, category: category, expenses: [expense1, expense2]}
    end

    test "displays expense list with proper formatting", %{conn: conn, expenses: expenses} do
      {:ok, view, html} = live(conn, ~p"/expenses")

      # Should show page title
      assert html =~ "Expenses"

      # Should show expense data
      assert html =~ "Weekly groceries"
      assert html =~ "$125.50"
      assert html =~ "Whole Foods"
      assert html =~ "Aug 15, 2024"

      assert html =~ "Gas station"
      assert html =~ "$45.20"
      assert html =~ "Shell"
    end

    test "shows expense summary statistics", %{conn: conn, expenses: expenses} do
      {:ok, view, html} = live(conn, ~p"/expenses")

      # Should show total expenses
      assert html =~ "$170.70" # 125.50 + 45.20

      # Should show expense count
      assert html =~ "2 expenses"

      # Should show current month total
      assert html =~ "This Month"
    end

    test "expense table has proper sortable columns", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/expenses")

      # Should have sortable column headers
      assert html =~ ~r/<th[^>]*data-sort="date"[^>]*>Date<\/th>/
      assert html =~ ~r/<th[^>]*data-sort="amount"[^>]*>Amount<\/th>/
      assert html =~ ~r/<th[^>]*data-sort="description"[^>]*>Description<\/th>/
      assert html =~ ~r/<th[^>]*data-sort="category"[^>]*>Category<\/th>/
      assert html =~ ~r/<th[^>]*>Actions<\/th>/
    end

    test "clicking sort headers changes expense order", %{conn: conn, expenses: expenses} do
      {:ok, view, html} = live(conn, ~p"/expenses")

      # Default sort should be by date desc (newest first)
      expense_rows = html |> Floki.find("tbody tr") |> Enum.map(&Floki.text/1)
      assert Enum.at(expense_rows, 0) =~ "Weekly groceries" # Aug 15 (newer)
      assert Enum.at(expense_rows, 1) =~ "Gas station" # Aug 10 (older)

      # Click amount header to sort by amount
      view |> element("[data-sort='amount']") |> render_click()

      html = render(view)
      expense_rows = html |> Floki.find("tbody tr") |> Enum.map(&Floki.text/1)
      # Should now be sorted by amount desc
      assert Enum.at(expense_rows, 0) =~ "Weekly groceries" # $125.50 (higher)
      assert Enum.at(expense_rows, 1) =~ "Gas station" # $45.20 (lower)
    end

    test "has Add Expense button", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/expenses")

      assert html =~ "Add Expense"
      assert has_element?(view, "a[href='/expenses/new']")
    end

    test "edit links navigate to expense edit page", %{conn: conn, expenses: [expense1, _expense2]} do
      {:ok, view, html} = live(conn, ~p"/expenses")

      # Should have edit links for each expense
      assert has_element?(view, "a[href='/expenses/#{expense1.id}/edit']")

      # Click edit link
      view |> element("a[href='/expenses/#{expense1.id}/edit']") |> render_click()

      # Should navigate to edit page
      assert_patch(view, ~p"/expenses/#{expense1.id}/edit")
    end
  end
end
```

#### 1.2 Expense Form Component Tests

```elixir
# test/ashfolio_web/live/expense_live/form_component_test.exs
defmodule AshfolioWeb.ExpenseLive.FormComponentTest do
  use AshfolioWeb.ConnCase, async: false
  import Phoenix.LiveViewTest

  describe "expense form component" do
    setup do
      # Reset account balances for clean test state
      require Ash.Query

      Ashfolio.Portfolio.Account
      |> Ash.Query.for_read(:read)
      |> Ash.read!()
      |> Enum.each(fn account ->
        Ashfolio.Portfolio.Account.update(account, %{balance: Decimal.new("0.00")})
      end)

      {:ok, checking_account} = Ashfolio.Portfolio.Account.create(%{
        name: "Test Checking",
        account_type: :checking,
        balance: Decimal.new("5000.00")
      })

      {:ok, category} = Ashfolio.FinancialManagement.TransactionCategory.create(%{
        name: "Groceries",
        color: "#4CAF50"
      })

      %{checking_account: checking_account, category: category}
    end

    test "new expense form renders all fields", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/expenses/new")

      # Should show form title
      assert html =~ "Add Expense"

      # Should have all required form fields
      assert has_element?(view, "input[name='expense[description]']")
      assert has_element?(view, "input[name='expense[amount]']")
      assert has_element?(view, "input[name='expense[date]']")
      assert has_element?(view, "input[name='expense[merchant]']")
      assert has_element?(view, "select[name='expense[category_id]']")
      assert has_element?(view, "select[name='expense[account_id]']")
      assert has_element?(view, "textarea[name='expense[notes]']")

      # Should have submit button
      assert has_element?(view, "button[type='submit']", "Save Expense")
    end

    test "form validates required fields", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/expenses/new")

      # Submit form without required fields
      view
      |> form("#expense-form", expense: %{})
      |> render_submit()

      html = render(view)

      # Should show validation errors
      assert html =~ "Description can't be blank"
      assert html =~ "Amount can't be blank"
      assert html =~ "Date can't be blank"
    end

    test "form validates amount is positive", %{conn: conn, checking_account: account} do
      {:ok, view, html} = live(conn, ~p"/expenses/new")

      view
      |> form("#expense-form", expense: %{
        description: "Test expense",
        amount: "-50.00",
        date: "2024-08-15",
        account_id: account.id
      })
      |> render_submit()

      html = render(view)
      assert html =~ "Amount must be greater than 0"
    end

    test "successful expense creation redirects to index", %{conn: conn, checking_account: account, category: category} do
      {:ok, view, html} = live(conn, ~p"/expenses/new")

      view
      |> form("#expense-form", expense: %{
        description: "Test expense",
        amount: "75.25",
        date: "2024-08-15",
        merchant: "Test Store",
        category_id: category.id,
        account_id: account.id,
        notes: "Test notes"
      })
      |> render_submit()

      # Should redirect to expenses index
      assert_redirect(view, ~p"/expenses")

      # Expense should be created in database
      expenses = Ashfolio.FinancialManagement.Expense.list!()
      assert length(expenses) == 1

      expense = List.first(expenses)
      assert expense.description == "Test expense"
      assert Decimal.equal?(expense.amount, Decimal.new("75.25"))
      assert expense.merchant == "Test Store"
    end

    test "category dropdown shows available categories", %{conn: conn, category: category} do
      {:ok, view, html} = live(conn, ~p"/expenses/new")

      # Should show category in dropdown
      assert html =~ ~r/<option[^>]*value="#{category.id}"[^>]*>Groceries<\/option>/
    end

    test "account dropdown shows available accounts", %{conn: conn, checking_account: account} do
      {:ok, view, html} = live(conn, ~p"/expenses/new")

      # Should show account in dropdown
      assert html =~ ~r/<option[^>]*value="#{account.id}"[^>]*>Test Checking<\/option>/
    end

    test "date field defaults to today", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/expenses/new")

      today = Date.utc_today() |> Date.to_iso8601()
      assert html =~ ~r/<input[^>]*name="expense\[date\]"[^>]*value="#{today}"[^>]*>/
    end
  end

  describe "edit expense form" do
    setup do
      # Reset account balances
      require Ash.Query

      Ashfolio.Portfolio.Account
      |> Ash.Query.for_read(:read)
      |> Ash.read!()
      |> Enum.each(fn account ->
        Ashfolio.Portfolio.Account.update(account, %{balance: Decimal.new("0.00")})
      end)

      {:ok, checking_account} = Ashfolio.Portfolio.Account.create(%{
        name: "Test Checking",
        account_type: :checking,
        balance: Decimal.new("5000.00")
      })

      {:ok, category} = Ashfolio.FinancialManagement.TransactionCategory.create(%{
        name: "Groceries",
        color: "#4CAF50"
      })

      {:ok, expense} = Ashfolio.FinancialManagement.Expense.create(%{
        description: "Original expense",
        amount: Decimal.new("100.00"),
        date: ~D[2024-08-10],
        merchant: "Original Store",
        category_id: category.id,
        account_id: checking_account.id
      })

      %{expense: expense, checking_account: checking_account, category: category}
    end

    test "edit form pre-populates with expense data", %{conn: conn, expense: expense} do
      {:ok, view, html} = live(conn, ~p"/expenses/#{expense.id}/edit")

      # Should show edit form title
      assert html =~ "Edit Expense"

      # Should pre-populate form fields
      assert html =~ ~r/<input[^>]*name="expense\[description\]"[^>]*value="Original expense"[^>]*>/
      assert html =~ ~r/<input[^>]*name="expense\[amount\]"[^>]*value="100.00"[^>]*>/
      assert html =~ ~r/<input[^>]*name="expense\[date\]"[^>]*value="2024-08-10"[^>]*>/
      assert html =~ ~r/<input[^>]*name="expense\[merchant\]"[^>]*value="Original Store"[^>]*>/
    end

    test "successful edit updates expense", %{conn: conn, expense: expense, category: category, checking_account: account} do
      {:ok, view, html} = live(conn, ~p"/expenses/#{expense.id}/edit")

      view
      |> form("#expense-form", expense: %{
        description: "Updated expense",
        amount: "150.75",
        date: "2024-08-12",
        merchant: "Updated Store",
        category_id: category.id,
        account_id: account.id
      })
      |> render_submit()

      # Should redirect back to index
      assert_redirect(view, ~p"/expenses")

      # Should update expense in database
      updated_expense = Ashfolio.FinancialManagement.Expense.get!(expense.id)
      assert updated_expense.description == "Updated expense"
      assert Decimal.equal?(updated_expense.amount, Decimal.new("150.75"))
      assert updated_expense.date == ~D[2024-08-12]
    end
  end
end
```

#### 1.3 Expense Filtering Tests

```elixir
# test/ashfolio_web/live/expense_live/filtering_test.exs
defmodule AshfolioWeb.ExpenseLive.FilteringTest do
  use AshfolioWeb.ConnCase, async: false
  import Phoenix.LiveViewTest

  describe "expense filtering" do
    setup do
      # Reset account balances
      require Ash.Query

      Ashfolio.Portfolio.Account
      |> Ash.Query.for_read(:read)
      |> Ash.read!()
      |> Enum.each(fn account ->
        Ashfolio.Portfolio.Account.update(account, %{balance: Decimal.new("0.00")})
      end)

      {:ok, checking_account} = Ashfolio.Portfolio.Account.create(%{
        name: "Test Checking",
        account_type: :checking,
        balance: Decimal.new("5000.00")
      })

      {:ok, groceries} = Ashfolio.FinancialManagement.TransactionCategory.create(%{
        name: "Groceries",
        color: "#4CAF50"
      })

      {:ok, gas} = Ashfolio.FinancialManagement.TransactionCategory.create(%{
        name: "Gas",
        color: "#FF9800"
      })

      # Create test expenses across different categories and dates
      {:ok, expense1} = Ashfolio.FinancialManagement.Expense.create(%{
        description: "Weekly groceries",
        amount: Decimal.new("125.50"),
        date: ~D[2024-08-15],
        category_id: groceries.id,
        account_id: checking_account.id
      })

      {:ok, expense2} = Ashfolio.FinancialManagement.Expense.create(%{
        description: "Fill up tank",
        amount: Decimal.new("45.20"),
        date: ~D[2024-08-10],
        category_id: gas.id,
        account_id: checking_account.id
      })

      {:ok, expense3} = Ashfolio.FinancialManagement.Expense.create(%{
        description: "Monthly groceries",
        amount: Decimal.new("200.00"),
        date: ~D[2024-07-25],
        category_id: groceries.id,
        account_id: checking_account.id
      })

      %{
        checking_account: checking_account,
        categories: %{groceries: groceries, gas: gas},
        expenses: [expense1, expense2, expense3]
      }
    end

    test "shows filter controls", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/expenses")

      # Should show filter form
      assert has_element?(view, "#expense-filters")

      # Should have category filter dropdown
      assert has_element?(view, "select[name='filter[category_id]']")

      # Should have date range filters
      assert has_element?(view, "input[name='filter[start_date]']")
      assert has_element?(view, "input[name='filter[end_date]']")

      # Should have search field
      assert has_element?(view, "input[name='filter[search]']")
    end

    test "filtering by category shows only matching expenses", %{conn: conn, categories: %{groceries: groceries}} do
      {:ok, view, html} = live(conn, ~p"/expenses")

      # Should initially show all expenses
      assert html =~ "Weekly groceries"
      assert html =~ "Fill up tank"
      assert html =~ "Monthly groceries"

      # Apply groceries category filter
      view
      |> form("#expense-filters", filter: %{category_id: groceries.id})
      |> render_change()

      html = render(view)

      # Should show only grocery expenses
      assert html =~ "Weekly groceries"
      assert html =~ "Monthly groceries"
      refute html =~ "Fill up tank"
    end

    test "filtering by date range shows only expenses in range", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/expenses")

      # Filter to August 2024 only
      view
      |> form("#expense-filters", filter: %{
        start_date: "2024-08-01",
        end_date: "2024-08-31"
      })
      |> render_change()

      html = render(view)

      # Should show only August expenses
      assert html =~ "Weekly groceries" # Aug 15
      assert html =~ "Fill up tank" # Aug 10
      refute html =~ "Monthly groceries" # July 25
    end

    test "search filter matches description text", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/expenses")

      # Search for "groceries"
      view
      |> form("#expense-filters", filter: %{search: "groceries"})
      |> render_change()

      html = render(view)

      # Should show only expenses with "groceries" in description
      assert html =~ "Weekly groceries"
      assert html =~ "Monthly groceries"
      refute html =~ "Fill up tank"
    end

    test "clear filters button resets all filters", %{conn: conn, categories: %{groceries: groceries}} do
      {:ok, view, html} = live(conn, ~p"/expenses")

      # Apply multiple filters
      view
      |> form("#expense-filters", filter: %{
        category_id: groceries.id,
        search: "weekly"
      })
      |> render_change()

      html = render(view)
      # Should show only filtered results
      assert html =~ "Weekly groceries"
      refute html =~ "Fill up tank"

      # Click clear filters
      view |> element("button[phx-click='clear_filters']") |> render_click()

      html = render(view)
      # Should show all expenses again
      assert html =~ "Weekly groceries"
      assert html =~ "Fill up tank"
      assert html =~ "Monthly groceries"
    end

    test "filter combinations work together", %{conn: conn, categories: %{groceries: groceries}} do
      {:ok, view, html} = live(conn, ~p"/expenses")

      # Apply category + date range filters
      view
      |> form("#expense-filters", filter: %{
        category_id: groceries.id,
        start_date: "2024-08-01",
        end_date: "2024-08-31"
      })
      |> render_change()

      html = render(view)

      # Should show only grocery expenses in August
      assert html =~ "Weekly groceries" # Groceries + August
      refute html =~ "Fill up tank" # Gas (wrong category)
      refute html =~ "Monthly groceries" # Groceries but July (wrong date)
    end
  end
end
```

## Feature 2: Contex Chart Integration

### Test-Driven Requirements

#### 2.1 Expense Category Pie Chart Tests

```elixir
# test/ashfolio_web/components/charts/expense_pie_chart_test.exs
defmodule AshfolioWeb.Components.Charts.ExpensePieChartTest do
  use AshfolioWeb.ConnCase, async: false
  import Phoenix.LiveViewTest

  describe "expense category pie chart" do
    setup do
      # Reset account balances
      require Ash.Query

      Ashfolio.Portfolio.Account
      |> Ash.Query.for_read(:read)
      |> Ash.read!()
      |> Enum.each(fn account ->
        Ashfolio.Portfolio.Account.update(account, %{balance: Decimal.new("0.00")})
      end)

      {:ok, checking_account} = Ashfolio.Portfolio.Account.create(%{
        name: "Test Checking",
        account_type: :checking,
        balance: Decimal.new("5000.00")
      })

      {:ok, groceries} = Ashfolio.FinancialManagement.TransactionCategory.create(%{
        name: "Groceries",
        color: "#4CAF50"
      })

      {:ok, gas} = Ashfolio.FinancialManagement.TransactionCategory.create(%{
        name: "Gas",
        color: "#FF9800"
      })

      {:ok, dining} = Ashfolio.FinancialManagement.TransactionCategory.create(%{
        name: "Dining Out",
        color: "#E91E63"
      })

      # Create test expenses with varying amounts
      {:ok, expense1} = Ashfolio.FinancialManagement.Expense.create(%{
        description: "Groceries 1",
        amount: Decimal.new("100.00"),
        date: ~D[2024-08-15],
        category_id: groceries.id,
        account_id: checking_account.id
      })

      {:ok, expense2} = Ashfolio.FinancialManagement.Expense.create(%{
        description: "Groceries 2",
        amount: Decimal.new("75.50"),
        date: ~D[2024-08-10],
        category_id: groceries.id,
        account_id: checking_account.id
      })

      {:ok, expense3} = Ashfolio.FinancialManagement.Expense.create(%{
        description: "Gas",
        amount: Decimal.new("45.25"),
        date: ~D[2024-08-12],
        category_id: gas.id,
        account_id: checking_account.id
      })

      {:ok, expense4} = Ashfolio.FinancialManagement.Expense.create(%{
        description: "Restaurant",
        amount: Decimal.new("85.75"),
        date: ~D[2024-08-14],
        category_id: dining.id,
        account_id: checking_account.id
      })

      %{
        checking_account: checking_account,
        categories: %{groceries: groceries, gas: gas, dining: dining},
        expenses: [expense1, expense2, expense3, expense4]
      }
    end

    test "expense analytics page renders pie chart", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/expenses/analytics")

      # Should show analytics page title
      assert html =~ "Expense Analytics"

      # Should contain Contex SVG chart
      assert html =~ ~r/<svg[^>]*class="[^"]*contex-pie-chart[^"]*"[^>]*>/

      # Should show chart title
      assert html =~ "Expenses by Category"
    end

    test "pie chart displays correct category data", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/expenses/analytics")

      # Should contain category labels in chart
      assert html =~ "Groceries"
      assert html =~ "Gas"
      assert html =~ "Dining Out"

      # Should show category totals
      # Groceries: $100.00 + $75.50 = $175.50
      # Gas: $45.25
      # Dining: $85.75
      assert html =~ "$175.50"
      assert html =~ "$45.25"
      assert html =~ "$85.75"
    end

    test "pie chart uses category colors", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/expenses/analytics")

      # Should use category colors in SVG
      assert html =~ "#4CAF50" # Groceries green
      assert html =~ "#FF9800" # Gas orange
      assert html =~ "#E91E63" # Dining pink
    end

    test "pie chart calculates percentages correctly", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/expenses/analytics")

      # Total: $175.50 + $45.25 + $85.75 = $306.50
      # Groceries: $175.50 / $306.50 = 57.3%
      # Gas: $45.25 / $306.50 = 14.8%
      # Dining: $85.75 / $306.50 = 28.0%

      assert html =~ "57.3%"
      assert html =~ "14.8%"
      assert html =~ "28.0%"
    end

    test "empty expenses shows appropriate message", %{conn: conn} do
      # Delete all expenses
      Ashfolio.FinancialManagement.Expense.list!()
      |> Enum.each(fn expense ->
        Ashfolio.FinancialManagement.Expense.destroy(expense)
      end)

      {:ok, view, html} = live(conn, ~p"/expenses/analytics")

      # Should show empty state message
      assert html =~ "No expenses to display"
      assert html =~ "Add your first expense to see analytics"

      # Should not show chart
      refute html =~ ~r/<svg[^>]*class="[^"]*contex-pie-chart[^"]*"[^>]*>/
    end

    test "single category shows appropriate chart", %{conn: conn} do
      # Delete all but one category of expenses
      Ashfolio.FinancialManagement.Expense.list!()
      |> Enum.reject(fn expense -> expense.category_id == get_groceries_category_id() end)
      |> Enum.each(fn expense ->
        Ashfolio.FinancialManagement.Expense.destroy(expense)
      end)

      {:ok, view, html} = live(conn, ~p"/expenses/analytics")

      # Should still show pie chart with single slice
      assert html =~ ~r/<svg[^>]*class="[^"]*contex-pie-chart[^"]*"[^>]*>/
      assert html =~ "Groceries"
      assert html =~ "100%" # Should show 100% for single category
    end

    defp get_groceries_category_id do
      categories = Ashfolio.FinancialManagement.TransactionCategory.list!()
      groceries = Enum.find(categories, &(&1.name == "Groceries"))
      groceries.id
    end
  end
end
```

#### 2.2 Net Worth Trend Chart Tests

```elixir
# test/ashfolio_web/components/charts/net_worth_trend_test.exs
defmodule AshfolioWeb.Components.Charts.NetWorthTrendTest do
  use AshfolioWeb.ConnCase, async: false
  import Phoenix.LiveViewTest

  describe "net worth trend chart" do
    setup do
      # Reset account balances
      require Ash.Query

      Ashfolio.Portfolio.Account
      |> Ash.Query.for_read(:read)
      |> Ash.read!()
      |> Enum.each(fn account ->
        Ashfolio.Portfolio.Account.update(account, %{balance: Decimal.new("0.00")})
      end)

      # Create historical net worth snapshots
      snapshots_data = [
        {~D[2024-06-01], "100000.00"},
        {~D[2024-07-01], "105000.00"},
        {~D[2024-08-01], "110000.00"},
        {~D[2024-08-15], "115000.00"}
      ]

      snapshots = for {date, value} <- snapshots_data do
        {:ok, snapshot} = Ashfolio.FinancialManagement.NetWorthSnapshot.create(%{
          snapshot_date: date,
          total_assets: Decimal.new(value),
          total_liabilities: Decimal.new("0.00"),
          net_worth: Decimal.new(value),
          investment_value: Decimal.new(value),
          cash_value: Decimal.new("0.00"),
          other_assets_value: Decimal.new("0.00")
        })
        snapshot
      end

      %{snapshots: snapshots}
    end

    test "net worth page renders trend chart", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/net_worth")

      # Should show net worth page title
      assert html =~ "Net Worth History"

      # Should contain Contex line chart
      assert html =~ ~r/<svg[^>]*class="[^"]*contex-line-chart[^"]*"[^>]*>/

      # Should show chart title
      assert html =~ "Net Worth Over Time"
    end

    test "trend chart displays historical snapshots", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/net_worth")

      # Should show snapshot values
      assert html =~ "$100,000" # June
      assert html =~ "$105,000" # July
      assert html =~ "$110,000" # August 1
      assert html =~ "$115,000" # August 15

      # Should show dates
      assert html =~ "Jun 2024"
      assert html =~ "Jul 2024"
      assert html =~ "Aug 2024"
    end

    test "trend chart shows positive growth styling", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/net_worth")

      # Should use positive growth color (green)
      assert html =~ "stroke=\"#22C55E\"" # Tailwind green-500

      # Should show growth percentage
      assert html =~ "+15.0%" # From $100k to $115k
    end

    test "current net worth is prominently displayed", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/net_worth")

      # Should show current (latest) net worth prominently
      assert html =~ ~r/<div[^>]*class="[^"]*net-worth-current[^"]*"[^>]*>.*\$115,000.*<\/div>/

      # Should show change from previous
      assert html =~ "+$5,000" # From $110k to $115k
      assert html =~ "+4.5%" # Percentage change
    end

    test "chart has proper time range controls", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/net_worth")

      # Should have time range buttons
      assert has_element?(view, "button[phx-click='set_range'][phx-value-range='3M']", "3M")
      assert has_element?(view, "button[phx-click='set_range'][phx-value-range='6M']", "6M")
      assert has_element?(view, "button[phx-click='set_range'][phx-value-range='1Y']", "1Y")
      assert has_element?(view, "button[phx-click='set_range'][phx-value-range='ALL']", "All")
    end

    test "clicking time range filters chart data", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/net_worth")

      # Initially should show all data points
      assert html =~ "Jun 2024"
      assert html =~ "Jul 2024"
      assert html =~ "Aug 2024"

      # Click 3M button to show last 3 months only
      view |> element("button[phx-click='set_range'][phx-value-range='3M']") |> render_click()

      html = render(view)

      # Should now only show recent months
      refute html =~ "Jun 2024" # More than 3 months ago
      assert html =~ "Aug 2024" # Within 3 months
    end

    test "empty snapshots shows create snapshot prompt", %{conn: conn} do
      # Delete all snapshots
      Ashfolio.FinancialManagement.NetWorthSnapshot.list!()
      |> Enum.each(fn snapshot ->
        Ashfolio.FinancialManagement.NetWorthSnapshot.destroy(snapshot)
      end)

      {:ok, view, html} = live(conn, ~p"/net_worth")

      # Should show empty state
      assert html =~ "No net worth history yet"
      assert html =~ "Create your first snapshot"

      # Should show create snapshot button
      assert has_element?(view, "button[phx-click='create_snapshot']", "Create Snapshot Now")

      # Should not show chart
      refute html =~ ~r/<svg[^>]*class="[^"]*contex-line-chart[^"]*"[^>]*>/
    end

    test "create snapshot button works", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/net_worth")

      # Should have create snapshot button
      assert has_element?(view, "button[phx-click='create_snapshot']")

      # Click create snapshot
      view |> element("button[phx-click='create_snapshot']") |> render_click()

      # Should show success message
      assert render(view) =~ "Net worth snapshot created successfully"

      # Should create new snapshot in database
      snapshots = Ashfolio.FinancialManagement.NetWorthSnapshot.list!()
      assert length(snapshots) == 5 # 4 existing + 1 new
    end
  end
end
```

## Feature 3: Dashboard Integration

### Test-Driven Requirements

#### 3.1 Dashboard Expense Widget Tests

```elixir
# test/ashfolio_web/live/dashboard_live/expense_widget_test.exs
defmodule AshfolioWeb.DashboardLive.ExpenseWidgetTest do
  use AshfolioWeb.ConnCase, async: false
  import Phoenix.LiveViewTest

  describe "dashboard expense widget" do
    setup do
      # Reset account balances
      require Ash.Query

      Ashfolio.Portfolio.Account
      |> Ash.Query.for_read(:read)
      |> Ash.read!()
      |> Enum.each(fn account ->
        Ashfolio.Portfolio.Account.update(account, %{balance: Decimal.new("0.00")})
      end)

      {:ok, checking_account} = Ashfolio.Portfolio.Account.create(%{
        name: "Test Checking",
        account_type: :checking,
        balance: Decimal.new("5000.00")
      })

      {:ok, category} = Ashfolio.FinancialManagement.TransactionCategory.create(%{
        name: "Groceries",
        color: "#4CAF50"
      })

      # Create current month expenses
      current_month_start = Date.beginning_of_month(Date.utc_today())

      {:ok, expense1} = Ashfolio.FinancialManagement.Expense.create(%{
        description: "This month expense 1",
        amount: Decimal.new("150.00"),
        date: current_month_start,
        category_id: category.id,
        account_id: checking_account.id
      })

      {:ok, expense2} = Ashfolio.FinancialManagement.Expense.create(%{
        description: "This month expense 2",
        amount: Decimal.new("75.50"),
        date: Date.add(current_month_start, 5),
        category_id: category.id,
        account_id: checking_account.id
      })

      # Create last month expense for comparison
      last_month = Date.add(current_month_start, -15)
      {:ok, expense3} = Ashfolio.FinancialManagement.Expense.create(%{
        description: "Last month expense",
        amount: Decimal.new("200.00"),
        date: last_month,
        category_id: category.id,
        account_id: checking_account.id
      })

      %{
        checking_account: checking_account,
        category: category,
        current_month_expenses: [expense1, expense2],
        last_month_expense: expense3
      }
    end

    test "dashboard shows expense summary widget", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/dashboard")

      # Should show expense widget
      assert has_element?(view, "[data-testid='expense-summary-widget']")

      # Should show current month total
      assert html =~ "This Month"
      assert html =~ "$225.50" # $150.00 + $75.50

      # Should show expense count
      assert html =~ "2 expenses"
    end

    test "expense widget shows month-over-month comparison", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/dashboard")

      # Should show percentage change
      # Current: $225.50, Last: $200.00 = +12.8% increase
      assert html =~ "+12.8%"
      assert html =~ "vs last month"
    end

    test "expense widget links to full expenses page", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/dashboard")

      # Should have link to expenses page
      assert has_element?(view, "a[href='/expenses']", "View All Expenses")
    end

    test "expense widget shows top category", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/dashboard")

      # Should show top spending category
      assert html =~ "Top Category"
      assert html =~ "Groceries"
      assert html =~ "$225.50" # Total for groceries category
    end

    test "add expense button in widget works", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/dashboard")

      # Should have quick add expense button
      assert has_element?(view, "button[phx-click='show_add_expense']", "Add Expense")

      # Click add expense button
      view |> element("button[phx-click='show_add_expense']") |> render_click()

      # Should show inline expense form
      assert has_element?(view, "#quick-expense-form")
      assert has_element?(view, "input[name='expense[description]']")
      assert has_element?(view, "input[name='expense[amount]']")
    end

    test "quick expense form submission works", %{conn: conn, category: category, checking_account: account} do
      {:ok, view, html} = live(conn, ~p"/dashboard")

      # Show add expense form
      view |> element("button[phx-click='show_add_expense']") |> render_click()

      # Fill and submit quick form
      view
      |> form("#quick-expense-form", expense: %{
        description: "Quick expense",
        amount: "25.99",
        category_id: category.id,
        account_id: account.id
      })
      |> render_submit()

      # Should create expense and update widget
      html = render(view)
      assert html =~ "$251.49" # Previous $225.50 + $25.99
      assert html =~ "3 expenses" # Was 2, now 3

      # Should hide form after submission
      refute has_element?(view, "#quick-expense-form")
    end

    test "empty expenses shows appropriate message", %{conn: conn} do
      # Delete all expenses
      Ashfolio.FinancialManagement.Expense.list!()
      |> Enum.each(fn expense ->
        Ashfolio.FinancialManagement.Expense.destroy(expense)
      end)

      {:ok, view, html} = live(conn, ~p"/dashboard")

      # Should show empty state in widget
      assert html =~ "$0.00"
      assert html =~ "0 expenses"
      assert html =~ "No expenses this month"
    end
  end
end
```

#### 3.2 Dashboard Net Worth Widget Tests

```elixir
# test/ashfolio_web/live/dashboard_live/net_worth_widget_test.exs
defmodule AshfolioWeb.DashboardLive.NetWorthWidgetTest do
  use AshfolioWeb.ConnCase, async: false
  import Phoenix.LiveViewTest

  describe "dashboard net worth widget" do
    setup do
      # Reset account balances
      require Ash.Query

      Ashfolio.Portfolio.Account
      |> Ash.Query.for_read(:read)
      |> Ash.read!()
      |> Enum.each(fn account ->
        Ashfolio.Portfolio.Account.update(account, %{balance: Decimal.new("0.00")})
      end)

      # Create accounts with balances
      {:ok, investment_account} = Ashfolio.Portfolio.Account.create(%{
        name: "Test Investment",
        account_type: :investment,
        balance: Decimal.new("75000.00")
      })

      {:ok, checking_account} = Ashfolio.Portfolio.Account.create(%{
        name: "Test Checking",
        account_type: :checking,
        balance: Decimal.new("5000.00")
      })

      # Create net worth snapshots for trend
      snapshots_data = [
        {Date.add(Date.utc_today(), -30), "78000.00"},
        {Date.add(Date.utc_today(), -15), "79000.00"},
        {Date.utc_today(), "80000.00"}
      ]

      snapshots = for {date, value} <- snapshots_data do
        {:ok, snapshot} = Ashfolio.FinancialManagement.NetWorthSnapshot.create(%{
          snapshot_date: date,
          total_assets: Decimal.new(value),
          total_liabilities: Decimal.new("0.00"),
          net_worth: Decimal.new(value),
          investment_value: Decimal.new(value),
          cash_value: Decimal.new("0.00"),
          other_assets_value: Decimal.new("0.00")
        })
        snapshot
      end

      %{
        investment_account: investment_account,
        checking_account: checking_account,
        snapshots: snapshots
      }
    end

    test "dashboard shows current net worth prominently", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/dashboard")

      # Should show current net worth (account balances: $75k + $5k = $80k)
      assert html =~ "$80,000"
      assert has_element?(view, "[data-testid='current-net-worth']")
    end

    test "net worth widget shows growth trend", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/dashboard")

      # Should show positive trend from snapshots
      # From $78k to $80k = +$2k = +2.6%
      assert html =~ "+$2,000"
      assert html =~ "+2.6%"
      assert html =~ "30 days"
    end

    test "net worth widget includes mini sparkline chart", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/dashboard")

      # Should contain sparkline SVG
      assert html =~ ~r/<svg[^>]*class="[^"]*sparkline[^"]*"[^>]*>/

      # Sparkline should use trend data
      assert html =~ "78000" # First snapshot value
      assert html =~ "80000" # Latest snapshot value
    end

    test "net worth widget shows breakdown by account type", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/dashboard")

      # Should show investment vs cash breakdown
      assert html =~ "Investment"
      assert html =~ "$75,000" # Investment account balance

      assert html =~ "Cash"
      assert html =~ "$5,000" # Checking account balance
    end

    test "create snapshot button in widget", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/dashboard")

      # Should have create snapshot button
      assert has_element?(view, "button[phx-click='create_snapshot']", "Snapshot Now")

      # Click create snapshot
      view |> element("button[phx-click='create_snapshot']") |> render_click()

      # Should show success message
      assert render(view) =~ "Net worth snapshot created"

      # Should create new snapshot in database
      snapshots = Ashfolio.FinancialManagement.NetWorthSnapshot.list!()
      assert length(snapshots) == 4 # 3 existing + 1 new
    end

    test "view net worth history link works", %{conn: conn} do
      {:ok, view, html} = live(conn, ~p"/dashboard")

      # Should have link to full net worth page
      assert has_element?(view, "a[href='/net_worth']", "View History")
    end

    test "handles missing snapshot data gracefully", %{conn: conn} do
      # Delete all snapshots
      Ashfolio.FinancialManagement.NetWorthSnapshot.list!()
      |> Enum.each(fn snapshot ->
        Ashfolio.FinancialManagement.NetWorthSnapshot.destroy(snapshot)
      end)

      {:ok, view, html} = live(conn, ~p"/dashboard")

      # Should still show current calculated net worth
      assert html =~ "$80,000"

      # Should show appropriate message for missing trend data
      assert html =~ "No trend data"
      assert html =~ "Create your first snapshot"

      # Should not show sparkline
      refute html =~ ~r/<svg[^>]*class="[^"]*sparkline[^"]*"[^>]*>/
    end

    test "net worth refreshes when accounts change", %{conn: conn, investment_account: account} do
      {:ok, view, html} = live(conn, ~p"/dashboard")

      # Initial net worth
      assert html =~ "$80,000"

      # Simulate account balance update (via PubSub in real app)
      Ashfolio.Portfolio.Account.update(account, %{balance: Decimal.new("85000.00")})

      # Trigger view refresh (in real app this would be automatic via PubSub)
      send(view.pid, {:account_updated, account.id})
      html = render(view)

      # Should show updated net worth ($85k + $5k = $90k)
      assert html =~ "$90,000"
    end
  end
end
```

## Implementation Success Criteria

### Technical Acceptance Criteria

#### âœ… Component Tests (Red-Green-Refactor)

- [ ] All ExpenseLive components pass unit tests
- [ ] All chart components render correctly with test data
- [ ] Dashboard widgets integrate seamlessly
- [ ] Form validations work as expected
- [ ] Filtering and sorting functions correctly

#### âœ… Visual Consistency

- [ ] Contex charts render with proper styling
- [ ] Color schemes consistent across widgets
- [ ] Responsive design works on mobile
- [ ] Loading states display appropriately
- [ ] Empty states show helpful messages

#### âœ… Performance Targets

- [ ] Expense list loads in <500ms with 1000+ expenses
- [ ] Charts render in <1000ms with realistic data
- [ ] Dashboard widgets update in <200ms
- [ ] Form submissions complete in <300ms

#### âœ… Browser Automation (Playwright)

- [ ] End-to-end user workflows complete successfully
- [ ] Chart interactions work (hover, click, zoom)
- [ ] Form submissions and validation work in all browsers
- [ ] Mobile responsive layouts verified
- [ ] Accessibility compliance (keyboard nav, screen readers)

### User Experience Success Metrics

#### âœ… Task Completion Times

- [ ] Add expense: <30 seconds
- [ ] View category breakdown: <10 seconds
- [ ] Create net worth snapshot: <5 seconds
- [ ] Filter expenses by date/category: <15 seconds
- [ ] Navigate between dashboard widgets: <3 seconds

#### âœ… Feature Discovery

- [ ] Users find expense analytics within 2 clicks
- [ ] Net worth trend immediately visible on dashboard
- [ ] Chart interactions discoverable without instruction
- [ ] Mobile users can complete all tasks

## Risk Mitigation Strategy

### Technical Risks

1. Contex Chart Performance: Test with large datasets early
2. LiveView State Management: Keep state minimal, use temporary assigns
3. Mobile Chart Rendering: Test touch interactions thoroughly
4. Data Loading Performance: Implement proper pagination and caching

### Development Approach

1. Component-First Development: Build and test each component in isolation
2. Progressive Enhancement: Start with tables, add charts incrementally
3. Mobile-First Design: Test responsive layouts continuously
4. Performance Monitoring: Benchmark each component as built

## Next Steps: Ready for v0.3.x Implementation!

### Development Kickoff Commands

```bash
# Create feature branch (adjust version as needed)
git checkout -b feature/v0.3.1-frontend-components

# Run existing backend tests to confirm foundation
mix test test/ashfolio/financial_management/

# Start with first TDD cycle
mix test test/ashfolio_web/live/expense_live/index_test.exs
```

### v0.3.1 TDD Implementation Order

1. Week 1: ExpenseLive components (Index â†’ Form â†’ Filtering)
2. Week 1.5: Contex chart integration (Pie chart â†’ Line chart)
3. Week 2: Dashboard widget integration and polish

### Future v0.3.x Extensions

This TDD specification can be extended for future releases:

- v0.3.2: Data Import/Export TDD patterns
- v0.3.3: Automation & Recurring TDD patterns
- v0.3.4: Enhanced Analytics TDD patterns

### Definition of Done Checklist

- [ ] All component tests pass (Red-Green-Refactor cycle complete)
- [ ] Charts render correctly with realistic data
- [ ] Dashboard integration seamless
- [ ] Mobile responsive verified
- [ ] Browser automation tests pass
- [ ] Performance targets met
- [ ] Code reviewed and documented

Ready to build beautiful, tested frontend components on our solid v0.3.0 foundation! ðŸš€
